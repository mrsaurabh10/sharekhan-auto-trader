<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Place Order</title>
    <meta charset="UTF-8">
    <!-- Bootstrap 5 (no SRI attributes to avoid CDN integrity mismatch in some environments) -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" defer></script>
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">
    <!-- Tom Select for searchable instrument dropdown -->
    <link href="https://cdn.jsdelivr.net/npm/tom-select/dist/css/tom-select.bootstrap5.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/tom-select/dist/js/tom-select.complete.min.js" defer></script>

    <style>
        body { font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; background:#f5f7fb; }
        .edit-row td { background: #f8f9fa; }
        .edit-input { width: 110px; }
        .small-btn { padding: 0.25rem 0.5rem; margin-left: 0.25rem; }
        /* Ensure icon and text buttons align vertically and have consistent sizing */
        .btn, .small-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: .35rem;
            line-height: 1;
        }
        /* Align bootstrap-icons inside buttons */
        .btn i, .small-btn i, .bi {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        /* Make action cell buttons a bit more compact and consistent */
        .table td .btn {
            padding: .25rem .45rem;
            height: auto;
        }
        /* compact table cells */
        .table-sm td, .table-sm th { padding: .45rem .6rem; }
        /* sticky table headers for better UX */
        .table-responsive thead th {
            position: sticky;
            top: 0;
            z-index: 3;
            background: linear-gradient(180deg,#ffffff,#f8f9fa);
        }
        .form-card { background: #fff; border-radius: 8px; padding: 16px; box-shadow: 0 1px 4px rgba(16,24,40,.04); }
        .muted-small { font-size: .85rem; color: #6c757d; }
        .status-badge { text-transform: uppercase; font-size: .7rem; }
        .status-PENDING { background:#f0ad4e; color:#fff; }
        .status-EXECUTED { background:#198754; color:#fff; }
        .status-EXIT_ORDER_PLACED { background:#0d6efd; color:#fff; }
        .status-PLACED_PENDING_CONFIRMATION { background:#6f42c1; color:#fff; }
        .status-REJECTED { background:#dc3545; color:#fff; }
        .status-EXITED_SUCCESS { background:#6c757d; color:#fff; }
    </style>
</head>
<body>

<div class="container my-4">
    <div class="d-flex align-items-center justify-content-between mb-3">
        <div>
            <h2 class="h4 mb-0">Place Order</h2>
            <div class="muted-small">Quickly create a trigger and monitor requests / executed trades</div>
        </div>
        <div id="last-refresh" class="text-muted small"></div>
    </div>

    <div id="result" class="mb-2"></div>

    <form id="placeOrderForm" method="POST" class="row g-3 form-card">
        <div class="col-md-3">
            <label for="exchange" class="form-label">Exchange</label>
            <select id="exchange" name="exchange" class="form-select" required>
                <option value="">Select Exchange</option>
                <option value="NF">NF</option>
                <option value="BF">BF</option>
                <option value="MX">MX</option>
                <option value="NC">NC</option>
                <option value="BC">BC</option>
            </select>
        </div>

        <div class="col-md-3">
            <label for="instrument" class="form-label">Instrument</label>
            <select id="instrument" name="instrument" class="form-select" required>
                <option value="">Select Instrument</option>
            </select>
        </div>

        <div class="col-md-2">
            <label for="strikePrice" class="form-label">Strike</label>
            <select id="strikePrice" name="strikePrice" class="form-select">
                <option value="">Select</option>
            </select>
        </div>

        <div class="col-md-2">
            <label for="expiry" class="form-label">Expiry</label>
            <select id="expiry" name="expiry" class="form-select">
                <option value="">Select</option>
            </select>
        </div>

        <div class="col-md-2">
            <label for="optionType" class="form-label">Option Type</label>
            <select id="optionType" name="optionType" class="form-select">
                <option value="">--</option>
                <option value="CE">Call</option>
                <option value="PE">Put</option>
            </select>
        </div>

        <div class="col-md-2">
            <label for="entryPrice" class="form-label">Entry Price</label>
            <input type="number" step="0.01" id="entryPrice" name="entryPrice" class="form-control" required>
        </div>

        <div class="col-md-2">
            <label for="stopLoss" class="form-label">Stop Loss</label>
            <input type="number" step="0.01" id="stopLoss" name="stopLoss" class="form-control" required>
        </div>

        <div class="col-md-2">
            <label for="target1" class="form-label">Target 1</label>
            <input type="number" step="0.01" id="target1" name="target1" class="form-control">
        </div>

        <div class="col-md-2">
            <label for="target2" class="form-label">Target 2</label>
            <input type="number" step="0.01" id="target2" name="target2" class="form-control">
        </div>

        <div class="col-md-2">
            <label for="target3" class="form-label">Target 3</label>
            <input type="number" step="0.01" id="target3" name="target3" class="form-control">
        </div>

        <div class="col-md-2">
            <label for="quantity" class="form-label">Quantity (Lots)</label>
            <input type="number" id="quantity" name="quantity" class="form-control" required th:default="1">
        </div>

        <div class="col-md-2 d-flex align-items-center">
            <div class="form-check mt-3">
                <input class="form-check-input" type="checkbox" id="intraday" name="intraday">
                <label class="form-check-label" for="intraday">Intraday</label>
            </div>
        </div>

        <div class="col-12 text-end">
            <button id="placeOrderBtn" type="submit" class="btn btn-primary"><i class="bi bi-send-fill me-1"></i> Place Order</button>
            <button type="button" class="btn btn-outline-secondary ms-2" onclick="document.getElementById('placeOrderForm').reset();"><i class="bi bi-x-circle me-1"></i> Reset</button>
        </div>
    </form>

    <div class="row mt-4">
        <div class="col-12">
            <h5 class="mb-2">Trading Requests</h5>
            <div class="table-responsive">
                <table id="trading-requests-table" class="table table-sm table-striped table-hover align-middle" style="width:100%;">
                    <thead class="table-light">
                    <tr>
                        <th>ID</th>
                        <th>Symbol</th>
                        <th>Exchange</th>
                        <th>Strike</th>
                        <th>Expiry</th>
                        <th>Entry Price</th>
                        <th>SL</th>
                        <th>Target 1</th>
                        <th>Qty</th>
                        <th>OptionType</th>
                        <th>Intraday</th>
                        <th>Status</th>
                        <th>Action</th>
                        <th>LTP</th>
                    </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <div class="col-12 mt-4">
            <div class="d-flex align-items-center justify-content-between mb-2">
                <h5 class="mb-0">Trades Executed</h5>
                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" id="showExitedSuccessToggle" checked>
                    <label class="form-check-label small" for="showExitedSuccessToggle">Show EXITED_SUCCESS</label>
                </div>
            </div>

            <div class="table-responsive">
                <table id="trades-executed-table" class="table table-sm table-striped table-hover align-middle" style="width:100%;">
                    <thead class="table-light">
                    <tr>
                        <th>ID</th>
                        <th>Symbol</th>
                        <th>Exchange</th>
                        <th>Strike</th>
                        <th>Expiry</th>
                        <th>Entry Price</th>
                        <th>SL</th>
                        <th>Target 1</th>
                        <th>Qty</th>
                        <th>OptionType</th>
                        <th>Intraday</th>
                        <th>Status</th>
                        <th>Action</th>
                        <th>LTP</th>
                        <th>PnL</th>
                    </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>
</div>

<script>

    // Global error handlers so uncaught exceptions don't silently stop other JS
    window.addEventListener('error', function (ev) {
        console.error('Global error caught:', ev.error || ev.message, ev);
        const r = document.getElementById('result');
        if (r) r.innerText = 'JS error: ' + (ev.error?.message || ev.message || ev.error || 'unknown');
    });
    window.addEventListener('unhandledrejection', function (ev) {
        console.error('Unhandled promise rejection:', ev.reason);
        const r = document.getElementById('result');
        if (r) r.innerText = 'Unhandled promise rejection: ' + (ev.reason?.message || ev.reason);
    });

    const instrumentCache = {}; // { exchange: [symbols] }
    let instrumentTS = null; // Tom Select instance
    const strikeCache = {};     // { exchange_instrument: [strikes] }
    const ltpSocket = new WebSocket(`ws://${window.location.host}/ws/ltp`);
    const scripLtpMap = {}; // scripCode -> LTP
    const executedTrades = {}; // orderId -> { entryPrice, quantity }
    const requestMap = {};
    const executionMap = {};

    const lastKnownLTP = {};
    const lastKnownPNL = {};

    function statusBadgeClass(status) {
        if (!status) return 'bg-secondary';
        const s = String(status).toUpperCase();
        switch (s) {
            case 'PENDING': return 'status-PENDING';
            case 'EXECUTED': return 'status-EXECUTED';
            case 'EXIT_ORDER_PLACED': return 'status-EXIT_ORDER_PLACED';
            case 'PLACED_PENDING_CONFIRMATION': return 'status-PLACED_PENDING_CONFIRMATION';
            case 'REJECTED': return 'status-REJECTED';
            case 'EXITED_SUCCESS': return 'status-EXITED_SUCCESS';
            default: return 'bg-secondary';
        }
    }

    function updateLastRefresh() {
        const el = document.getElementById('last-refresh');
        if (el) el.innerText = 'Last refresh: ' + new Date().toLocaleTimeString();
    }

    // Utility: fetch with AbortController timeout to avoid hanging requests
    function fetchWithTimeout(url, opts = {}, timeoutMs = 6000) {
        const controller = new AbortController();
        const signal = controller.signal;
        const timer = setTimeout(() => controller.abort(), timeoutMs);
        return fetch(url, { ...opts, signal })
            .finally(() => clearTimeout(timer));
    }

    ltpSocket.onmessage = function (event) {
        const payload = JSON.parse(event.data);
        const scripCode = payload.scripCode;
        const ltp = payload.ltp;
        scripLtpMap[scripCode] = ltp;

        // üîÑ Update LTP and PnL in the UI
        updateTradingRequestLTP(scripCode, ltp);
        updateExecutedTradeLTP(scripCode, ltp);
    };

    // Helper to call backend MStock LTP endpoint for a qualified key like "NFO:CDSL25JAN2220CE"
    function fetchMStockLtpForKey(qualifiedKey) {
        if (!qualifiedKey) return Promise.resolve(null);
        const url = `/api/mstock/ltp?i=${encodeURIComponent(qualifiedKey)}`;
        return fetchWithTimeout(url)
            .then(res => res.json())
            .then(json => {
                if (!json || json.status !== 'success' || !json.data) return null;
                const entry = json.data[qualifiedKey];
                if (!entry) return null;
                // last_price may be integer or number string ‚Äî return numeric value
                return Number(entry.last_price);
            })
            .catch(err => {
                console.error('Failed to fetch MStock LTP for', qualifiedKey, err);
                return null;
            });
    }

    function updateTradingRequestLTP(scripCode, ltp) {
        const formatted = (ltp != null && !isNaN(ltp)) ? ltp.toFixed(2) : '-';
        document.querySelectorAll(`#trading-requests-table tbody tr`).forEach(row => {
            const cell = row.querySelector(`[data-scrip="${scripCode}"]`);
            if (!cell) return;
            if ((cell.innerText || '') !== formatted) cell.innerText = formatted;
        });
    }

    function updateExecutedTradeLTP(scripCode, ltp) {
         const scripKey = String(scripCode);
         lastKnownLTP[scripKey] = ltp;

         document.querySelectorAll('#trades-executed-table tbody tr').forEach(row => {
            // skip rejected or inactive (EXITED_SUCCESS) rows
            if (row.dataset.inactive === 'true' || row.dataset.rejected === 'true') return;
             const cell = row.querySelector(`[data-scrip="${scripKey}"]`);
             const pnlCell = row.querySelector(`[data-pnl="${scripKey}"]`);

             if (!cell || !pnlCell) return;

             const entry = parseFloat(row.dataset.entry) || 0;
             const qty = parseInt(row.dataset.qty) || 1;
             const pnl = (ltp - entry) * qty;
             lastKnownPNL[scripKey] = pnl;

             const ltpStr = (ltp != null && !isNaN(ltp)) ? ltp.toFixed(2) : '-';
             const pnlStr = isFinite(pnl) ? (pnl >= 0 ? '+' : '') + pnl.toFixed(0) : '-';

             if ((cell.textContent || '') !== ltpStr) cell.textContent = ltpStr;
             if ((pnlCell.textContent || '') !== pnlStr) {
                 pnlCell.textContent = pnlStr;
                 pnlCell.style.color = (Number(pnl) >= 0) ? 'green' : 'red';
             } else {
                 // Still ensure color is correct if value unchanged but sign might have changed (rare)
                 pnlCell.style.color = (Number(pnl) >= 0) ? 'green' : 'red';
             }
         });
     }



    // Fetch all symbols for NF, BF, NC and BC on page load
     function preloadInstruments() {
         ['NF', 'BF', 'NC', 'BC'].forEach(exchange => {
              const url = `/api/scripts/instruments/${encodeURIComponent(exchange)}`;
              console.debug('Preloading instruments from', url);
              fetchWithTimeout(url)
                  .then(res => {
                      if (!res.ok) throw new Error('HTTP ' + res.status + ' when fetching instruments for ' + exchange);
                      return res.json();
                  })
                  .then(data => {
                      instrumentCache[exchange] = Array.isArray(data?.instruments) ? data.instruments : [];
                      console.debug('Instruments cached for', exchange, instrumentCache[exchange].length);
                      // If Tom Select already initialized and current exchange matches, preload options
                      if (instrumentTS && document.getElementById('exchange').value === exchange) {
                          populateInstruments(instrumentCache[exchange]);
                      }
                  })
                  .catch(err => {
                      console.error(`Failed to preload instruments for ${exchange}:`, err);
                      const r = document.getElementById('result');
                      if (r) r.innerText = `Failed to preload instruments for ${exchange}: ${err.message}`;
                  });
          });
     }

    // Load instruments when exchange is selected
    document.getElementById('exchange').addEventListener('change', function () {
        try {
            const exchange = this.value;
            console.debug('Exchange selected:', exchange);

            // Debug: show cache state
            try { console.debug('instrumentCache entry for', exchange, instrumentCache[exchange]); } catch (e) { console.debug('instrumentCache check failed', e); }

            const instrumentSelect = document.getElementById('instrument');
            instrumentSelect.innerHTML = '<option value="">Select Instrument</option>';

            if (!exchange) return;
            // Disable optionType for no-strike exchanges (NC/BC)
            const optionTypeSelect = document.getElementById('optionType');
            const exchUpper = (exchange || '').toUpperCase();
            const noStrikeExchanges = new Set(['NC','BC']);
            if (noStrikeExchanges.has(exchUpper)) {
                if (optionTypeSelect) {
                    optionTypeSelect.value = '';
                    optionTypeSelect.disabled = true;
                }
            } else {
                if (optionTypeSelect) optionTypeSelect.disabled = false;
            }

            // Ensure Tom Select is initialized
            initInstrumentTomSelect();

            // If we have cached instruments (non-empty) populate Tom Select immediately so the UI is responsive.
            if (instrumentTS && Array.isArray(instrumentCache[exchange]) && instrumentCache[exchange].length > 0) {
                console.debug('Using cached instruments for', exchange, '(populating Tom Select immediately)');
                populateInstruments(instrumentCache[exchange]);
            }

            // Always fetch fresh from the API to ensure the latest data and to handle cases where preload returned empty.
            const url = `/api/scripts/instruments/${encodeURIComponent(exchange)}`;
            console.debug('Fetching instruments from (always):', url, 'cachePresent=', Array.isArray(instrumentCache[exchange]));
            fetchWithTimeout(url)
                .then(res => {
                    if (!res.ok) throw new Error('HTTP ' + res.status + ' when fetching instruments for ' + exchange);
                    return res.json();
                })
                .then(data => {
                    const instruments = Array.isArray(data?.instruments) ? data.instruments : [];
                    instrumentCache[exchange] = instruments; // üíæ Cache it
                    console.debug('Fetched instruments', instruments.length, 'for', exchange, '(post-fetch)');
                    if (instruments.length === 0) {
                        instrumentSelect.innerHTML = '<option value="">No instruments available</option>';
                        instrumentSelect.disabled = true;
                        document.getElementById('strikePrice').innerHTML = '<option value="">-</option>';
                        document.getElementById('strikePrice').disabled = true;
                        document.getElementById('expiry').innerHTML = '<option value="">-</option>';
                        document.getElementById('expiry').disabled = true;
                        document.getElementById('entryPrice').value = '';
                        return;
                    }
                    // ensure instrument select is enabled before populating (Tom Select handles UI)
                    if (instrumentTS) {
                        populateInstruments(instruments);
                    } else {
                        instrumentSelect.disabled = false;
                        populateInstruments(instruments);
                    }
                    // If this is a no-strike exchange, also ensure optionType is disabled (in case fetch changed state)
                    const optionTypeSelect2 = document.getElementById('optionType');
                    if (optionTypeSelect2) {
                        const exUp = (exchange || '').toUpperCase();
                        if (exUp === 'NC' || exUp === 'BC') {
                            optionTypeSelect2.value = '';
                            optionTypeSelect2.disabled = true;
                        } else {
                            optionTypeSelect2.disabled = false;
                        }
                    }
                 })
                .catch(err => {
                    console.error('Failed to load instruments:', err);
                    const r = document.getElementById('result');
                    if (r) r.innerText = `Failed to load instruments for ${exchange}: ${err.message}`;
                });
        } catch (e) {
            console.error('Exchange change handler failed', e);
            const r = document.getElementById('result'); if (r) r.innerText = 'Exchange handler error: ' + e.message;
        }
    });

    function populateInstruments(instruments) {
        const instrumentSelect = document.getElementById('instrument');
        const parent = instrumentSelect.parentNode;
        const existingSearch = document.getElementById('instrument-search');

        // Legacy (non-TomSelect) rendering helpers
        const RENDER_THRESHOLD = 500; // if more than this, show search box and render limited results
        const RENDER_LIMIT = 300;     // max number of options to render at a time
        function renderOptions(list) {
            instrumentSelect.disabled = false;
            let html = '<option value="">Select Instrument</option>';
            if (list && list.length) html += list.map(s => `<option value="${s}">${s}</option>`).join('');
            instrumentSelect.innerHTML = html;
        }
        function filterAndRender(q) {
            const term = (q || '').trim().toUpperCase();
            let matched = instruments;
            if (term) matched = instruments.filter(s => s.toUpperCase().includes(term));
            if (matched.length > RENDER_LIMIT) {
                renderOptions(matched.slice(0, RENDER_LIMIT));
                const r = document.getElementById('result'); if (r) r.innerText = `${matched.length} matches ‚Äî showing first ${RENDER_LIMIT}. Keep typing to narrow.`;
            } else {
                renderOptions(matched);
                const r = document.getElementById('result'); if (r) r.innerText = '';
            }
        }

        // If Tom Select is present, use its async loading / option management to avoid adding thousands of <option>
        if (instrumentTS) {
            instrumentTS.clearOptions();
            if (!Array.isArray(instruments) || instruments.length === 0) {
                // no options
                return;
            }

            // Add up to RENDER_LIMIT options initially; Tom Select search handles filtering
            const initial = instruments.slice(0, RENDER_LIMIT).map(s => ({value: s, text: s}));
            instrumentTS.addOption(initial);
            instrumentTS.refreshOptions(false);
            return;
        }

        // If Tom Select not in use, fall back to legacy rendering
        if (!Array.isArray(instruments) || instruments.length === 0) {
            if (existingSearch) existingSearch.remove();
            renderOptions([]);
            return;
        }

        if (instruments.length <= RENDER_THRESHOLD) {
            if (existingSearch) existingSearch.remove();
            renderOptions(instruments);
            const r = document.getElementById('result'); if (r) r.innerText = '';
            return;
        }

        // Large list: show a search input (create if missing)
        let searchEl = existingSearch;
        if (!searchEl) {
            searchEl = document.createElement('input');
            searchEl.id = 'instrument-search';
            searchEl.type = 'search';
            searchEl.placeholder = `Type to filter ${instruments.length} instruments...`;
            searchEl.className = 'form-control mb-2';
            parent.insertBefore(searchEl, instrumentSelect);
            // listen for input and debounce
            let debounceTimer = null;
            searchEl.addEventListener('input', function () {
                clearTimeout(debounceTimer);
                const v = this.value;
                debounceTimer = setTimeout(() => filterAndRender(v), 150);
            });
        } else {
            searchEl.placeholder = `Type to filter ${instruments.length} instruments...`;
            searchEl.value = '';
        }

        // initial render: first N instruments (no filter)
        filterAndRender('');
    }

    // Initialize Tom Select for the #instrument select once
    function initInstrumentTomSelect() {
        if (instrumentTS) return;
        try {
            instrumentTS = new TomSelect('#instrument', {
                valueField: 'value',
                labelField: 'text',
                searchField: 'text',
                create: false,
                maxOptions: 100,
                preload: false,
                render: {
                    option: function(item, escape) { return `<div>${escape(item.text)}</div>`; }
                },
                load: function(query, callback) {
                    const exchange = document.getElementById('exchange').value;
                    if (!exchange) { callback(); return; }
                    const list = instrumentCache[exchange];
                    if (!list) {
                        // fetch fresh instruments then filter
                        fetchWithTimeout(`/api/scripts/instruments/${encodeURIComponent(exchange)}`)
                            .then(res => res.json())
                            .then(json => {
                                instrumentCache[exchange] = Array.isArray(json?.instruments) ? json.instruments : [];
                                filterAndReturn(instrumentCache[exchange], query, callback);
                            }).catch(() => callback());
                    } else {
                        filterAndReturn(list, query, callback);
                    }

                    function filterAndReturn(list, q, cb) {
                        if (!Array.isArray(list) || list.length === 0) { cb([]); return; }
                        if (!q) cb(list.slice(0,300).map(s=>({value:s,text:s})));
                        else cb(list.filter(s => s.toUpperCase().includes(q.toUpperCase())).slice(0,300).map(s=>({value:s,text:s})));
                    }
                }
            });
        } catch (e) {
            console.warn('Tom Select init failed', e);
            instrumentTS = null;
        }
    }

    // Resolve option trading symbol (and scripCode) for the given selection using backend lookup
    function resolveOptionTradingSymbol(exchange, instrument, strikePrice, optionType, expiry) {
        const params = new URLSearchParams();
        params.set('exchange', exchange);
        params.set('instrument', instrument);
        params.set('strikePrice', strikePrice);
        params.set('optionType', optionType);
        params.set('expiry', expiry);

        return fetchWithTimeout(`/api/scripts/option?${params.toString()}`)
            .then(res => { if (!res.ok) return null; return res.json(); })
             .then(json => {
                 // expected { tradingSymbol: '...', scripCode: 12345 }
                 return json;
             })
             .catch(err => {
                console.error('Failed to resolve option trading symbol', err);
                return null;
            });
    }

    function buildQualifiedOptionKey(exchange, symbol, expiryStr, strike, optionType) {
        if (!exchange || !symbol || !expiryStr || !strike || !optionType) return null;

        const exchangeMap = {
            'NF': 'NFO',
            'BF': 'BFO'
        };
        const mappedExchange = exchangeMap[exchange] || exchange;

        // Custom month letter mapping based on your provided scheme
        function monthNumToLetter(m) {
            const monthLetterMap = {
                1: 'J',  // JAN
                2: 'F',  // FEB
                3: 'M',  // MAR
                4: 'A',  // APR
                5: 'M',  // MAY
                6: 'J',  // JUN
                7: 'J',  // JUL
                8: 'A',  // AUG
                9: 'S',  // SEP
                10: 'O', // OCT
                11: 'N', // NOV
                12: 'D'  // DEC
            };
            return monthLetterMap[m] || 'X';
        }

        // Parse expiry string to Date object
        let expiryDate = null;
        if (expiryStr.includes('/')) {
            const parts = expiryStr.split('/').map(s => s.trim());
            if (parts.length === 3) {
                const day = Number(parts[0]);
                const month = Number(parts[1]) - 1;
                const year = Number(parts[2]);
                expiryDate = new Date(year, month, day);
            }
        } else {
            const norm = expiryStr.replace(/[^0-9]/g, '');
            if (norm.length === 8) {
                const year = Number(norm.substring(0,4));
                const month = Number(norm.substring(4,6)) - 1;
                const day = Number(norm.substring(6,8));
                expiryDate = new Date(year, month, day);
            }
        }

        if (!expiryDate || isNaN(expiryDate.getTime())) {
            console.warn('Invalid expiry date format', expiryStr);
            return null;
        }

        const year = expiryDate.getFullYear();
        const month = expiryDate.getMonth();

        // Find last expiry day in the month for a given weekday
        function getLastExpiryDay(y, m, expiryWeekday) {
            const lastDay = new Date(y, m + 1, 0);
            const lastDate = lastDay.getDate();
            for(let d = lastDate; d > lastDate - 7; d--) {
                const date = new Date(y, m, d);
                if (date.getDay() === expiryWeekday) return date;
            }
            return null;
        }

        // Weekly expiry weekday by symbol: Sunday=0 ... Tuesday=2, Thursday=4
        let weeklyExpiryDay = null;
        if(symbol === 'NIFTY') weeklyExpiryDay = 2; // Tuesday
        else if(symbol === 'SENSEX') weeklyExpiryDay = 4; // Thursday
        else weeklyExpiryDay = 4; // Default to Thursday

        const lastExpiry = getLastExpiryDay(year, month, weeklyExpiryDay);

        // Is weekly expiry if expiryDate is on weeklyExpiryDay AND not the last expiry of the month
        const isWeekly = expiryDate.getDay() === weeklyExpiryDay &&
            expiryDate.getDate() !== lastExpiry.getDate();

        let expiryFormatted = '';
        if (isWeekly) {
            const yy = String(year).slice(-2);
            const monLetter = monthNumToLetter(month + 1);
            const dd = expiryDate.getDate().toString().padStart(2, '0');
            expiryFormatted = `${yy}${monLetter}${dd}`;
        } else {
            const yy = String(year).slice(-2);
            const monthNames = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
            expiryFormatted = `${yy}${monthNames[month]}`;
        }

        // Format strike, removing trailing decimal if whole number
        const strikeNum = Number(strike);
        const strikeStr = strikeNum % 1 === 0 ? `${strikeNum}` : strikeNum.toFixed(1);

        return `${mappedExchange}:${symbol}${expiryFormatted}${strikeStr}${optionType}`;
    }



    // Load strikes and expiries when instrument is selected
    // When instrument is selected, load (or use cached) strikes
    document.getElementById('instrument').addEventListener('change', function () {
        const exchange = document.getElementById('exchange').value;
        const instrument = this.value;

        if (!exchange || !instrument) return;

        const noStrikeExchanges = new Set(['NC','BC']);
        const isNoStrike = noStrikeExchanges.has((exchange || '').toUpperCase());

        if (isNoStrike) {
            // disable strike and expiry UI and fetch underlying LTP for the instrument
            const strikeSelect = document.getElementById('strikePrice');
            strikeSelect.innerHTML = `<option value="">-</option>`;
            strikeSelect.value = '';
            strikeSelect.disabled = true;

            const expirySelect = document.getElementById('expiry');
            expirySelect.innerHTML = `<option value="">-</option>`;
            expirySelect.value = '';
            expirySelect.disabled = true;

            // fetch underlying LTP and set as entry price (map NF->NSE, BF->BSE as before)
            const underlyingExchangeMap = { 'NF': 'NSE', 'BF': 'BSE', 'NC': 'NSE', 'BC': 'BSE' };
            const mappedExchange = underlyingExchangeMap[exchange] || exchange;
            const qualified = `${mappedExchange}:${instrument}`;
            fetchMStockLtpForKey(qualified).then(ltp => {
                if (ltp != null) document.getElementById('entryPrice').value = ltp;
            }).catch(err => console.warn('Failed to fetch underlying LTP for instrument', err));
            return;
        }

        const cacheKey = `${exchange}_${instrument}`;
        if (strikeCache[cacheKey]) {
            populateStrikeDropdown(strikeCache[cacheKey]);
            // after populating strikes from cache, fetch underlying LTP and pick nearest strike (if strikes cached)
            fetchUnderlyingAndSelectNearestStrike(exchange, instrument, strikeCache[cacheKey]);
        } else {
            fetchWithTimeout(`/api/scripts/strikes?exchange=${encodeURIComponent(exchange)}&instrument=${encodeURIComponent(instrument)}`)
                .then(res => res.json())
                .then(data => {
                    const strikes = data.strikes || [];
                    strikeCache[cacheKey] = strikes;
                    populateStrikeDropdown(strikes);
                    // after caching strikes, fetch underlying LTP and select nearest
                    fetchUnderlyingAndSelectNearestStrike(exchange, instrument, strikes);
                })
                .catch(err => {
                    console.error("Failed to load strikes:", err);
                });
        }
    });

    // Auto-select middle strike
    function populateStrikeDropdown(strikes) {
        const strikeSelect = document.getElementById('strikePrice');
        strikeSelect.innerHTML = '<option value="">Select Strike</option>';

        strikes.forEach(strike => {
            strikeSelect.innerHTML += `<option value="${strike}">${strike}</option>`;
        });

        // Do NOT auto-select the middle strike here. Nearest strike will be selected
        // by fetchUnderlyingAndSelectNearestStrike after we fetch the underlying LTP.
        autoSelectOptionTypeIfValid();
    }

    document.getElementById('strikePrice').addEventListener('change', function () {
        autoSelectOptionTypeIfValid();
    });

    // Load expiries when strike is selected
    document.getElementById('strikePrice').addEventListener('change', function () {
        const exchange = document.getElementById('exchange').value;
        const instrument = document.getElementById('instrument').value;
        const strikePrice = this.value;

        if (!exchange || !instrument || !strikePrice) return;

        fetchWithTimeout(`/api/scripts/expiries?exchange=${encodeURIComponent(exchange)}&instrument=${encodeURIComponent(instrument)}&strikePrice=${encodeURIComponent(strikePrice)}`)
            .then(res => res.json())
            .then(data => {
                const expiries = data.expiries || [];
                const expirySelect = document.getElementById('expiry');
                expirySelect.innerHTML = '<option value="">Select Expiry</option>';

                expiries.forEach((expiry, index) => {
                    const selected = index === 0 ? 'selected' : '';
                    expirySelect.innerHTML += `<option value="${expiry}" ${selected}>${expiry}</option>`;
                });

                // after expiry and optionType are set, resolve and fetch option LTP to populate entry price
                const selectedExpiry = expirySelect.value;
                const optionType = document.getElementById('optionType').value || 'CE';

                if (selectedExpiry) {
                    // Build qualified option key per requested format and fetch LTP directly
                    const qualifiedKey = buildQualifiedOptionKey(exchange, instrument, selectedExpiry, strikePrice, optionType);
                    if (qualifiedKey) {
                        fetchMStockLtpForKey(qualifiedKey).then(ltp => {
                            if (ltp != null) {
                                document.getElementById('entryPrice').value = ltp;
                            }
                        });
                    }
                }

            })
            .catch(err => {
                console.error("Failed to load expiries:", err);
            });
    });

    // Whenever expiry or option type changes, re-resolve option trading symbol and populate entry price
    function fetchOptionLtpAndPopulateEntry() {
        const exchange = document.getElementById('exchange').value;
        const instrument = document.getElementById('instrument').value;
        const strikePrice = document.getElementById('strikePrice').value;
        const optionType = document.getElementById('optionType').value || 'CE';
        const expiry = document.getElementById('expiry').value;

        const noStrikeExchanges = new Set(['NC','BC']);
        const isNoStrike = noStrikeExchanges.has((exchange || '').toUpperCase());

        // For NC/BC exchanges, fetch underlying LTP directly
        if (isNoStrike) {
            if (!exchange || !instrument) return;
            const underlyingExchangeMap = { 'NF': 'NSE', 'BF': 'BSE', 'NC': 'NSE', 'BC': 'BSE' };
            const mappedExchange = underlyingExchangeMap[exchange] || exchange;
            const qualified = `${mappedExchange}:${instrument}`;
            fetchMStockLtpForKey(qualified)
                .then(ltp => { if (ltp != null) document.getElementById('entryPrice').value = ltp; })
                .catch(err => console.warn('Failed to fetch underlying LTP for instrument', err));
            return;
        }

        if (!exchange || !instrument || !strikePrice || !expiry) return;

        const qualifiedKey = buildQualifiedOptionKey(exchange, instrument, expiry, strikePrice, optionType);
        if (!qualifiedKey) return;
        fetchMStockLtpForKey(qualifiedKey)
            .then(ltp => {
                if (ltp != null) {
                    document.getElementById('entryPrice').value = ltp;
                }
            })
            .catch(err => console.warn('Failed to fetch option LTP', err));
    }

    document.getElementById('expiry').addEventListener('change', function () {
        fetchOptionLtpAndPopulateEntry();
    });

    document.getElementById('optionType').addEventListener('change', function () { fetchOptionLtpAndPopulateEntry(); });

    // Submit form via REST - add spinner/disable behavior
    document.getElementById('placeOrderForm').addEventListener('submit', function (e) {
         e.preventDefault();

         const form = e.target;
         const submitBtn = document.getElementById('placeOrderBtn');
         const originalHtml = submitBtn.innerHTML;
         submitBtn.disabled = true;
         submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span> Placing...';

        const exch = (form.exchange && form.exchange.value) ? form.exchange.value.toUpperCase() : '';
        const noStrikeExchanges = new Set(['NC','BC']);
        const isNoStrike = noStrikeExchanges.has(exch);
         const data = {
             exchange: form.exchange.value,
             instrument: form.instrument.value,
            // If NC/BC (no-strike exchanges) send strikePrice as null and expiry as null
            strikePrice: isNoStrike ? null : (form.strikePrice.value ? parseFloat(form.strikePrice.value) : null),
            expiry: isNoStrike ? null : (form.expiry.value || null),
             entryPrice: parseFloat(form.entryPrice.value),
             stopLoss: parseFloat(form.stopLoss.value),
             target1: parseFloat(form.target1.value) || 0,
             target2: parseFloat(form.target2.value) || 0,
             target3: parseFloat(form.target3.value) || 0,
             // Per request, optionType should be empty for equities
            optionType: isNoStrike ? '' : (form.optionType.value || null),
              quantity: parseInt(form.quantity.value),
              intraday: form.intraday.checked
          };

        fetch('/api/trades/trigger-on-price', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(data)
        }).then(res => {
            if (!res.ok) throw new Error("Failed to trigger order");
            return res.text();
        }).then(msg => {
            document.getElementById('result').innerHTML = '<span class="text-success">‚úÖ Order Triggered</span>';
            form.reset();
            loadRequestedOrders();
        }).catch(err => {
            document.getElementById('result').innerHTML = `<span class="text-danger">‚ùå Failed to trigger order: ${err.message}</span>`;
            console.error(err);
        }).finally(() => {
            submitBtn.disabled = false;
            submitBtn.innerHTML = originalHtml;
        });
    });

    function autoSelectOptionTypeIfValid() {
        const instrument = document.getElementById('instrument').value;
        const strike = document.getElementById('strikePrice').value;

        if (instrument && strike) {
            document.getElementById('optionType').value = 'CE'; // Auto-select Call
        }
    }

    function cancelTradeRequest(id) {
        if (!confirm("Are you sure you want to cancel this trade request?")) return;

        fetch(`/api/trades/cancel-request/${id}`, {
            method: 'POST'
        }).then(res => {
            if (!res.ok) throw new Error("Cancel failed");
            return res.text();
        }).then(() => {
            alert("‚úÖ Trade request cancelled");
            loadRequestedOrders();
        }).catch(err => {
            console.error("‚ùå Cancel failed", err);
            alert("‚ùå Failed to cancel request");
        });
    }

    function squareOffTrade(id) {
        if (!confirm("Are you sure you want to square off this trade?")) return;

        fetch(`/api/trades/square-off/${id}`, {
            method: 'POST'
        }).then(res => {
            if (!res.ok) throw new Error("Square off failed");
            return res.text();
        }).then(() => {
            alert("‚úÖ Trade squared off");
            loadTradeSetups();
        }).catch(err => {
            console.error("‚ùå Square off failed", err);
            alert("‚ùå Failed to square off trade");
        });
    }

    function moveSLtoCost(id) {
        if (!confirm("Are you sure you want to move the sl to cost?")) return;


        fetch(`/api/trades/move-sl-to-cost/${id}`, {
            method: 'POST'
        }).then(res => {
            if (!res.ok) throw new Error("MoveSltoCost failed");
            return res.text();
        }).then(() => {
            alert("‚úÖ Sl Moved to Cost");
            loadTradeSetups();
        }).catch(err => {
            console.error("‚ùå Sl Cost failed", err);
            alert("‚ùå Failed to move sl to cost");
        });
    }

    // Inline edit helpers for Requests & Executions
    function createEditRow(columnsCount, id) {
        const tr = document.createElement('tr');
        tr.className = 'edit-row';
        tr.dataset.editingFor = id;
        // create TDs equal to columnsCount
        for (let i = 0; i < columnsCount; i++) {
            const td = document.createElement('td');
            tr.appendChild(td);
        }
        return tr;
    }

    function editRequest(id) {
        const order = requestMap[id];
        if (!order) {
            alert('Trade request data not available locally. Refreshing requests.');
            loadRequestedOrders();
            return;
        }
        // remove any existing edit row
        cancelEditRow();

        const tbody = document.querySelector('#trading-requests-table tbody');
        // find row by data-id attribute (more robust than matching innerText)
        const row = tbody.querySelector(`tr[data-id="${id}"]`);
        const headerRow = document.querySelector('#trading-requests-table thead tr');
        const columnsCount = headerRow ? headerRow.children.length : 14; // fallback to 14 columns if header not found
        const editRow = createEditRow(columnsCount, 'req_' + id);

        // build inputs for SL, target1, target2, target3 and intraday and save/cancel buttons
        editRow.children[0].innerText = '';
        editRow.children[1].innerText = order.symbol || '';
        editRow.children[2].innerText = order.exchange || '';
        editRow.children[3].innerText = order.strikePrice || '';
        editRow.children[4].innerText = order.expiry || '';

        // Entry
        const entryInput = document.createElement('input');
        entryInput.type = 'number'; entryInput.step = '0.01'; entryInput.value = order.entryPrice || '';
        entryInput.className = 'edit-input';
        editRow.children[5].appendChild(entryInput);

        // SL
        const slInput = document.createElement('input');
        slInput.type = 'number'; slInput.step = '0.01'; slInput.value = order.stopLoss || '';
        slInput.className = 'edit-input';
        editRow.children[6].appendChild(slInput);

        // Target1
        const t1Input = document.createElement('input');
        t1Input.type = 'number'; t1Input.step = '0.01'; t1Input.value = order.target1 || '';
        t1Input.className = 'edit-input';
        editRow.children[7].appendChild(t1Input);

        // Target2
        const t2Input = document.createElement('input');
        t2Input.type = 'number'; t2Input.step = '0.01'; t2Input.value = order.target2 || '';
        t2Input.className = 'edit-input';
        // small spacing
        const t2Label = document.createElement('div'); t2Label.style.display='inline-block'; t2Label.style.marginLeft='6px';
        t2Label.appendChild(t2Input);
        editRow.children[7].appendChild(t2Label);

        // Target3
        const t3Input = document.createElement('input');
        t3Input.type = 'number'; t3Input.step = '0.01'; t3Input.value = order.target3 || '';
        t3Input.className = 'edit-input';
        const t3Label = document.createElement('div'); t3Label.style.display='inline-block'; t3Label.style.marginLeft='6px';
        t3Label.appendChild(t3Input);
        editRow.children[7].appendChild(t3Label);

        // Qty
        const qtyInput = document.createElement('input');
        qtyInput.type = 'number'; qtyInput.step = '1'; qtyInput.value = order.quantity || '';
        qtyInput.className = 'edit-input';
        editRow.children[8].appendChild(qtyInput);

        // OptionType
         editRow.children[9].innerText = order.optionType || '';

        // Intraday checkbox
        const intradayBox = document.createElement('input');
        intradayBox.type = 'checkbox';
        intradayBox.checked = !!order.intraday;
        editRow.children[10].appendChild(intradayBox);

        // Status
        editRow.children[11].innerText = order.status || '';

        // Actions: Save/Cancel
        const saveBtn = document.createElement('button');
        saveBtn.className = 'small-btn';
        saveBtn.innerText = 'Save';
        saveBtn.onclick = function () {
            saveRequestEdit(id, {
                stopLoss: slInput.value,
                target1: t1Input.value,
                quantity: qtyInput.value,
                target2: t2Input.value,
                target3: t3Input.value,
                intraday: intradayBox.checked
            });
            return false;
        };

        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'small-btn';
        cancelBtn.innerText = 'Cancel';
        cancelBtn.onclick = function () { cancelEditRow(); return false; };

        editRow.children[12].appendChild(saveBtn);
        editRow.children[12].appendChild(cancelBtn);

        // LTP cell left blank (last cell)
        editRow.children[13].innerText = '--';

        // insert after the target row
        if (row) row.parentNode.insertBefore(editRow, row.nextSibling);
        else tbody.appendChild(editRow);
    }

    function saveRequestEdit(id, payload) {
        // build object with only non-empty values
        const body = {};
        if (payload.stopLoss !== null && payload.stopLoss !== '') body.stopLoss = parseFloat(payload.stopLoss);
        if (payload.target1 !== null && payload.target1 !== '') body.target1 = parseFloat(payload.target1);
        if (payload.target2 !== null && payload.target2 !== '') body.target2 = parseFloat(payload.target2);
        if (payload.target3 !== null && payload.target3 !== '') body.target3 = parseFloat(payload.target3);
        if (payload.quantity !== null && payload.quantity !== '' && !isNaN(payload.quantity)) body.quantity = parseInt(payload.quantity);
         if (typeof payload.intraday === 'boolean') body.intraday = payload.intraday;

         if (Object.keys(body).length === 0) { alert('No changes to save'); return; }

         fetch(`/api/trades/request/${id}`, {
             method: 'PUT',
             headers: {'Content-Type': 'application/json'},
             body: JSON.stringify(body)
         }).then(res => {
             if (!res.ok) throw new Error('Update failed');
             return res.json();
         }).then(updated => {
             alert('‚úÖ Updated request');
             cancelEditRow();
             loadRequestedOrders();
         }).catch(err => {
             console.error('Failed to update request', err);
             alert('‚ùå Failed to update request');
         });
     }

    function editExecution(id) {
         const setup = executionMap[id];
         if (!setup) {
            alert('Executed trade data not available locally. Refreshing executions.');
            loadTradeSetups();
            return;
        }
        // Do not allow editing rejected trades
        if (setup.status === 'REJECTED') {
            alert('Cannot edit a rejected execution');
            return;
        }
         cancelEditRow();

         const tbody = document.querySelector('#trades-executed-table tbody');
         // find row by data-id attribute (more robust than matching innerText)
         const row = tbody.querySelector(`tr[data-id="${id}"]`);
        const headerRow = document.querySelector('#trades-executed-table thead tr');
        const columnsCount = headerRow ? headerRow.children.length : 15; // fallback to 15 columns if header not found
        const editRow = createEditRow(columnsCount, 'exec_' + id);

        editRow.children[0].innerText = '';
        editRow.children[1].innerText = setup.symbol || '';
        editRow.children[2].innerText = setup.exchange || '';
        editRow.children[3].innerText = setup.strikePrice || '';
        editRow.children[4].innerText = setup.expiry || '';

        // Entry
        const entryInput = document.createElement('input');
        entryInput.type = 'number'; entryInput.step = '0.01'; entryInput.value = setup.entryPrice || '';
        entryInput.className = 'edit-input';
        editRow.children[5].appendChild(entryInput);

        // SL
        const slInput = document.createElement('input');
        slInput.type = 'number'; slInput.step = '0.01'; slInput.value = setup.stopLoss || '';
        slInput.className = 'edit-input';
        editRow.children[6].appendChild(slInput);

        // Target1
        const t1Input = document.createElement('input');
        t1Input.type = 'number'; t1Input.step = '0.01'; t1Input.value = setup.target1 || '';
        t1Input.className = 'edit-input';
        editRow.children[7].appendChild(t1Input);

        // Target2
        const t2Input = document.createElement('input');
        t2Input.type = 'number'; t2Input.step = '0.01'; t2Input.value = setup.target2 || '';
        t2Input.className = 'edit-input';
        const t2Label = document.createElement('div'); t2Label.style.display='inline-block'; t2Label.style.marginLeft='6px';
        t2Label.appendChild(t2Input);
        editRow.children[7].appendChild(t2Label);

        // Target3
        const t3Input = document.createElement('input');
        t3Input.type = 'number'; t3Input.step = '0.01'; t3Input.value = setup.target3 || '';
        t3Input.className = 'edit-input';
        const t3Label = document.createElement('div'); t3Label.style.display='inline-block'; t3Label.style.marginLeft='6px';
        t3Label.appendChild(t3Input);
        editRow.children[7].appendChild(t3Label);

        // Qty
        editRow.children[8].innerText = setup.quantity || '';

        // OptionType
        editRow.children[9].innerText = setup.optionType || '';

        // Intraday checkbox
        const intradayBox = document.createElement('input');
        intradayBox.type = 'checkbox';
        intradayBox.checked = !!setup.intraday;
        editRow.children[10].appendChild(intradayBox);

        // Status
        editRow.children[11].innerText = setup.status || '';

        // Actions: Save/Cancel
        const saveBtn = document.createElement('button');
        saveBtn.className = 'small-btn';
        saveBtn.innerText = 'Save';
        saveBtn.onclick = function () {
            saveExecutionEdit(id, {
                stopLoss: slInput.value,
                target1: t1Input.value,
                target2: t2Input.value,
                target3: t3Input.value,
                intraday: intradayBox.checked
            });
            return false;
        };

        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'small-btn';
        cancelBtn.innerText = 'Cancel';
        cancelBtn.onclick = function () { cancelEditRow(); return false; };

        editRow.children[12].appendChild(saveBtn);
        editRow.children[12].appendChild(cancelBtn);

        // LTP and PnL cells
        editRow.children[13].innerText = lastKnownLTP[setup.scripCode] ?? '-';
        editRow.children[14].innerText = lastKnownPNL[setup.scripCode] ?? '-';

        if (row) row.parentNode.insertBefore(editRow, row.nextSibling);
        else tbody.appendChild(editRow);
    }

    function saveExecutionEdit(id, payload) {
        const body = {};
        if (payload.stopLoss !== null && payload.stopLoss !== '') body.stopLoss = parseFloat(payload.stopLoss);
        if (payload.target1 !== null && payload.target1 !== '') body.target1 = parseFloat(payload.target1);
        if (payload.target2 !== null && payload.target2 !== '') body.target2 = parseFloat(payload.target2);
        if (payload.target3 !== null && payload.target3 !== '') body.target3 = parseFloat(payload.target3);
        if (typeof payload.intraday === 'boolean') body.intraday = payload.intraday;

        if (Object.keys(body).length === 0) { alert('No changes to save'); return; }

        fetch(`/api/trades/execution/${id}`, {
            method: 'PUT',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(body)
        }).then(res => {
            if (!res.ok) throw new Error('Update failed');
            return res.json();
        }).then(updated => {
            alert('‚úÖ Updated execution');
            cancelEditRow();
            loadTradeSetups();
        }).catch(err => {
            console.error('Failed to update execution', err);
            alert('‚ùå Failed to update execution');
        });
    }

    function cancelEditRow() {
        document.querySelectorAll('.edit-row').forEach(r => r.remove());
    }

    // Update loadRequestedOrders to add Edit button and data for editing
    function loadRequestedOrders() {
        try {
            // If user is editing a request inline, skip the automatic refresh to avoid wiping the editor
            if (document.querySelector('.edit-row[data-editing-for^="req_"]')) {
                console.debug('Skipping loadRequestedOrders() because a request is being edited');
                return;
            }

            console.debug('loadRequestedOrders() starting');
            fetchWithTimeout('/api/orders/requests')
                 .then(res => res.json())
                 .then(data => {
                    updateLastRefresh();
                    const tbody = document.querySelector('#trading-requests-table tbody');
                    // build set of current ids present in new data
                    const incomingIds = new Set();

                    data.forEach(order => {
                        requestMap[order.id] = order; // cache
                        const id = String(order.id);
                        incomingIds.add(id);

                        let row = tbody.querySelector(`tr[data-id="${id}"]`);
                        if (!row) {
                            // create new row (with status badge and tooltip-enabled action buttons)
                            const badgeClass = statusBadgeClass(order.status);
                            row = document.createElement('tr');
                            row.dataset.id = id;
                            row.innerHTML = `
                                <td>${order.id}</td>
                                <td>${order.symbol}</td>
                                <td>${order.exchange}</td>
                                <td>${order.strikePrice}</td>
                                <td>${order.expiry}</td>
                                <td>${order.entryPrice}</td>
                                <td>${order.stopLoss}</td>
                                <td>${order.target1}</td>
                                <td>${order.quantity || ''}</td>
                                <td>${order.optionType || ''}</td>
                                <td>${order.intraday || ''}</td>
                                <td><span class="badge status-badge ${badgeClass}">${order.status || ''}</span></td>
                                <td>
                                    <button onclick="cancelTradeRequest(${order.id})" class="btn btn-sm btn-danger" data-bs-toggle="tooltip" title="Cancel this request"><i class="bi bi-x-lg"></i></button>
                                    <button onclick="editRequest(${order.id})" class="btn btn-sm btn-secondary ms-1" data-bs-toggle="tooltip" title="Edit this request"><i class="bi bi-pencil"></i></button>
                                </td>
                                <td data-scrip="${order.scripCode || ''}">--</td>`;
                            tbody.appendChild(row);
                        } else {
                            // update only changed cells to avoid flicker
                            const tds = row.children;
                            function updateCell(idx, value) {
                                value = value == null ? '' : String(value);
                                if ((tds[idx].innerText || '') !== value) tds[idx].innerText = value;
                            }

                            updateCell(1, order.symbol);
                            updateCell(2, order.exchange);
                            updateCell(3, order.strikePrice);
                            updateCell(4, order.expiry);
                            updateCell(5, order.entryPrice);
                            updateCell(6, order.stopLoss);
                            updateCell(7, order.target1);
                            updateCell(8, order.quantity || '');
                            updateCell(9, order.optionType || '');
                            updateCell(10, order.intraday || '');
                            // status cell: update badge
                            const statusTd = tds[11];
                            const newBadgeClass = statusBadgeClass(order.status);
                            const newStatusHtml = `<span class="badge status-badge ${newBadgeClass}">${order.status || ''}</span>`;
                            if ((statusTd.innerHTML || '').trim() !== newStatusHtml.trim()) statusTd.innerHTML = newStatusHtml;

                            // update scrip cell attribute if changed
                            const scripCell = row.querySelector('td[data-scrip]');
                            if (scripCell && (scripCell.dataset.scrip !== String(order.scripCode))) {
                                scripCell.dataset.scrip = order.scripCode || '';
                                scripCell.innerText = '--';
                            }
                        }
                    });

                    // Remove rows that are no longer present
                    Array.from(tbody.querySelectorAll('tr[data-id]')).forEach(r => {
                        if (!incomingIds.has(r.dataset.id)) r.remove();
                    });

                    // re-init tooltips on newly created buttons
                    initTooltips();
                })
                .catch(err => {
                    console.error('Failed to load requested orders', err);
                    const r = document.getElementById('result'); if (r) r.innerText = 'Failed to load requested orders: ' + err.message;
                });
        } catch (e) {
            console.error('loadRequestedOrders() error', e);
            const r = document.getElementById('result'); if (r) r.innerText = 'loadRequestedOrders error: ' + e.message;
        }
     }

     // Update loadTradeSetups to add Edit button for executed trades
     function loadTradeSetups() {
        try {
            // If user is editing an execution inline, skip the automatic refresh to avoid wiping the editor
            if (document.querySelector('.edit-row[data-editing-for^="exec_"]')) {
                console.debug('Skipping loadTradeSetups() because an execution is being edited');
                return;
            }

            console.debug('loadTradeSetups() starting');
            fetchWithTimeout('/api/orders/executed')
                .then(res => res.json())
                .then(data => {
                    updateLastRefresh();
                    const tbody = document.querySelector('#trades-executed-table tbody');
                    const incomingIds = new Set();

                    // Filter data to only include the required statuses and respect user toggle for EXITED_SUCCESS
                    try {
                        const showExited = !!(document.getElementById('showExitedSuccessToggle') && document.getElementById('showExitedSuccessToggle').checked);
                        // Include PLACED_PENDING_CONFIRMATION so pending/placed trades show in the Executed/Monitoring table
                        const allowed = new Set(['EXECUTED', 'EXIT_ORDER_PLACED', 'PLACED_PENDING_CONFIRMATION']);
                        if (showExited) allowed.add('EXITED_SUCCESS');

                        // Keep only entries with allowed status
                        const filtered = (data || []).filter(d => allowed.has(String(d.status)));

                        if (showExited) {
                            // For EXITED_SUCCESS keep only the latest per symbol+qty+entry (assume higher id is latest)
                            const latestExitByKey = new Map();
                            filtered.forEach(d => {
                                if (String(d.status) === 'EXITED_SUCCESS') {
                                    const key = `${d.symbol || d.tradingSymbol || d.scripCode || ''}|${d.quantity || ''}|${d.entryPrice || ''}`;
                                    const existing = latestExitByKey.get(key);
                                    if (!existing || (Number(d.id || 0) > Number(existing.id || 0))) {
                                        latestExitByKey.set(key, d);
                                    }
                                }
                            });

                            // Build finalData: include EXECUTED and EXIT_ORDER_PLACED as-is, and only the latest EXITED_SUCCESS entries from map
                            const finalData = [];
                            filtered.forEach(d => {
                                if (String(d.status) === 'EXITED_SUCCESS') {
                                    const key = `${d.symbol || d.tradingSymbol || d.scripCode || ''}|${d.quantity || ''}|${d.entryPrice || ''}`;
                                    const chosen = latestExitByKey.get(key);
                                    if (chosen && String(chosen.id) === String(d.id)) finalData.push(d);
                                } else {
                                    finalData.push(d);
                                }
                            });

                            data = finalData; // replace data with filtered set for rendering below
                        } else {
                            // showExited is false: exclude EXITED_SUCCESS entirely, data already filtered
                            data = filtered;
                        }
                    } catch (e) {
                        console.debug('Failed to filter executed trades, falling back to original data', e);
                    }

                    data.forEach(setup => {
                        executionMap[setup.id] = setup;
                        const id = String(setup.id);
                        incomingIds.add(id);
                        const isRejected = setup.status === 'REJECTED';
                        const isExitedSuccess = setup.status === 'EXITED_SUCCESS';
                        const isInactive = isRejected || isExitedSuccess;

                        let row = tbody.querySelector(`tr[data-id="${id}"]`);
                        if (!row) {
                            // build row
                            const badgeClass = statusBadgeClass(setup.status);
                            const actionCellHtml = isInactive ? '<td></td>' : `
                                <td>
                                    <button onclick="squareOffTrade(${setup.id})" class="btn btn-sm btn-danger" data-bs-toggle="tooltip" title="Close this trade"><i class="bi bi-x-circle"></i></button>
                                    <button onclick="moveSLtoCost(${setup.id})" class="btn btn-sm btn-warning ms-1" data-bs-toggle="tooltip" title="Move SL to cost"><i class="bi bi-arrow-up-right-circle"></i></button>
                                    <button onclick="editExecution(${setup.id})" class="btn btn-sm btn-secondary ms-1" data-bs-toggle="tooltip" title="Edit this execution"><i class="bi bi-pencil"></i></button>
                                </td>`;

                            const ltpHtml = isInactive ? '<td class="ltp">-</td><td class="pnl">-</td>' :
                                `<td class="ltp" data-scrip="${setup.scripCode}">${lastKnownLTP[setup.scripCode] ?? '-'}</td>
                                 <td class="pnl" data-pnl="${setup.scripCode}">${lastKnownPNL[setup.scripCode] ?? '-'}</td>`;

                            row = document.createElement('tr');
                            row.dataset.id = id;
                            row.dataset.scrip = setup.scripCode || '';
                            row.dataset.entry = setup.entryPrice || '';
                            row.dataset.qty = setup.quantity || 0;
                            row.dataset.rejected = isRejected ? 'true' : 'false';
                            row.dataset.inactive = isExitedSuccess ? 'true' : 'false';

                            row.innerHTML = `
                                <td>${setup.id}</td>
                                <td>${setup.symbol}</td>
                                <td>${setup.exchange || ''}</td>
                                <td>${setup.strikePrice || ''}</td>
                                <td>${setup.expiry || ''}</td>
                                <td>${setup.entryPrice || ''}</td>
                                <td>${setup.stopLoss || ''}</td>
                                <td>${setup.target1 || ''}</td>
                                <td>${setup.quantity || ''}</td>
                                <td>${setup.optionType || ''}</td>
                                <td>${setup.intraday || ''}</td>
                                <td><span class="badge status-badge ${badgeClass}">${setup.status || ''}</span></td>
                                ${actionCellHtml}
                                ${ltpHtml}`;
                            tbody.appendChild(row);
                        } else {
                            // update only changed cells
                            const tds = row.children;
                            function updateCell(idx, value) {
                                value = value == null ? '' : String(value);
                                if ((tds[idx].innerText || '') !== value) tds[idx].innerText = value;
                            }

                            updateCell(1, setup.symbol);
                            updateCell(2, setup.exchange || '');
                            updateCell(3, setup.strikePrice || '');
                            updateCell(4, setup.expiry || '');
                            updateCell(5, setup.entryPrice || '');
                            updateCell(6, setup.stopLoss || '');
                            updateCell(7, setup.target1 || '');
                            updateCell(8, setup.quantity || '');
                            updateCell(9, setup.optionType || '');
                            updateCell(10, setup.intraday || '');
                            // status badge
                            const statusTd = tds[11];
                            const newBadgeClass = statusBadgeClass(setup.status);
                            const newStatusHtml = `<span class="badge status-badge ${newBadgeClass}">${setup.status || ''}</span>`;
                            if ((statusTd.innerHTML || '').trim() !== newStatusHtml.trim()) statusTd.innerHTML = newStatusHtml;

                            // update attributes
                            if (row.dataset.rejected !== (isRejected ? 'true' : 'false')) {
                                row.dataset.rejected = isRejected ? 'true' : 'false';
                            }
                            // mark inactive if EXITED_SUCCESS
                            if (row.dataset.inactive !== (isExitedSuccess ? 'true' : 'false')) {
                                row.dataset.inactive = isExitedSuccess ? 'true' : 'false';
                            }
                            if (row.dataset.entry !== String(setup.entryPrice)) row.dataset.entry = setup.entryPrice || '';
                            if (row.dataset.qty !== String(setup.quantity || 0)) row.dataset.qty = String(setup.quantity || 0);

                            // update action cell and ltp/pnl if rejection state changed
                            if (isInactive) {
                                // ensure action cell empty and ltp/pnl show '-'
                                const actionTd = tds[12];
                                if (actionTd) actionTd.innerHTML = '';
                                const ltpTd = tds[13];
                                const pnlTd = tds[14];
                                if (ltpTd) ltpTd.innerText = '-';
                                if (pnlTd) pnlTd.innerText = '-';
                            } else {
                                // if previously inactive we should re-insert buttons and data-scrip attributes
                                const actionTd = tds[12];
                                if (actionTd && actionTd.innerHTML.trim() === '') {
                                    actionTd.innerHTML = ` <button onclick="squareOffTrade(${setup.id})" class="btn btn-sm btn-danger" data-bs-toggle="tooltip" title="Close this trade"><i class="bi bi-x-circle"></i></button> <button onclick="moveSLtoCost(${setup.id})" class="btn btn-sm btn-warning ms-1" data-bs-toggle="tooltip" title="Move SL to cost"><i class="bi bi-arrow-up-right-circle"></i></button> <button onclick="editExecution(${setup.id})" class="btn btn-sm btn-secondary ms-1" data-bs-toggle="tooltip" title="Edit this execution"><i class="bi bi-pencil"></i></button>`;
                                }
                                const ltpTd = tds[13];
                                const pnlTd = tds[14];
                                if (ltpTd) {
                                    ltpTd.dataset.scrip = setup.scripCode || '';
                                    if ((ltpTd.innerText || '') !== (lastKnownLTP[setup.scripCode] != null ? String(lastKnownLTP[setup.scripCode]) : '-')) {
                                        ltpTd.innerText = lastKnownLTP[setup.scripCode] != null ? (lastKnownLTP[setup.scripCode]).toString() : '-';
                                    }
                                }
                                if (pnlTd) {
                                    pnlTd.dataset.pnl = setup.scripCode || '';
                                    if ((pnlTd.innerText || '') !== (lastKnownPNL[setup.scripCode] != null ? String(lastKnownPNL[setup.scripCode]) : '-')) {
                                        pnlTd.innerText = lastKnownPNL[setup.scripCode] != null ? (lastKnownPNL[setup.scripCode]).toString() : '-';
                                    }
                                }
                            }
                         }
                     });

                     // Remove rows that are no longer present
                     Array.from(tbody.querySelectorAll('tr[data-id]')).forEach(r => {
                         if (!incomingIds.has(r.dataset.id)) r.remove();
                     });

                     // re-init tooltips
                     initTooltips();
                 })
                .catch(err => {
                    console.error('Failed to load trade setups', err);
                    const r = document.getElementById('result'); if (r) r.innerText = 'Failed to load trade setups: ' + err.message;
                });
        } catch (e) {
            console.error('loadTradeSetups() error', e);
            const r = document.getElementById('result'); if (r) r.innerText = 'loadTradeSetups error: ' + e.message;
        }
     }





    // Initialization: attach listeners and run initial loads when DOM is ready
    function initPlaceOrderPage() {
        // Attach event listeners that reference DOM elements (already done earlier in this script)
        // Run initial data fetches
        initInstrumentTomSelect();
        preloadInstruments();
         loadRequestedOrders();
         loadTradeSetups();

         // Initialize bootstrap tooltips
         initTooltips();

         // periodic refresh
         setInterval(() => {
             loadRequestedOrders(); // To reflect deletions if trade is executed
             loadTradeSetups();      // To reflect new setups
         }, 5000); // every 5 sec
     }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initPlaceOrderPage);
    } else {
        // DOM already available
        initPlaceOrderPage();
    }

    function initTooltips() {
        try {
            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.forEach(function (el) {
                // eslint-disable-next-line no-undef
                if (typeof bootstrap !== 'undefined' && bootstrap.Tooltip) new bootstrap.Tooltip(el);
            });
        } catch (e) {
            // ignore if bootstrap not available yet
            console.debug('Tooltips init failed:', e.message);
        }
    }

    function fetchUnderlyingAndSelectNearestStrike(exchange, instrument, strikes) {
        // Map UI exchange to MStock underlying exchange codes
        const underlyingExchangeMap = { 'NF': 'NSE', 'BF': 'BSE' };
        const fnIndices = ['NIFTY', 'BANKNIFTY', 'FINNIFTY', 'MIDCPNIFTY'];
        const bfoIndices = ['SENSEX', 'BANKEX'];
        let qualified = '';

        const now = new Date();
        const yy = String(now.getFullYear()).slice(-2);
        const monthNames = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
        const mon = monthNames[now.getMonth()];

        if (fnIndices.includes(instrument)) {
            // NSE Index Futures: NFO:{symbol}{yy}{MON}FUT
            qualified = `NFO:${instrument}${yy}${mon}FUT`;
        } else if (bfoIndices.includes(instrument)) {
            // BSE Index Futures: BFO:{symbol}{yy}{MON}FUT
            qualified = `BFO:${instrument}${yy}${mon}FUT`;
        } else {
            // Regular NSE/BSE equity
            let mappedExchange = underlyingExchangeMap[exchange] || exchange;
            qualified = `${mappedExchange}:${instrument}`;
        }

        // build qualified key like 'NSE:ACC' or 'BSE:ACC'
        fetchMStockLtpForKey(qualified)
            .then(ltp => {
                if (ltp == null) return;

                // find nearest numeric strike from the provided strikes list
                const numericStrikes = strikes.map(s => Number(s)).filter(n => !isNaN(n));
                if (numericStrikes.length === 0) return;

                let nearest = numericStrikes[0];
                let bestDiff = Math.abs(nearest - ltp);
                numericStrikes.forEach(s => {
                    const diff = Math.abs(s - ltp);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        nearest = s;
                    }
                });
                const nearestStr = String(nearest);
                const strikeValue = nearestStr.includes('.') ? nearestStr : `${nearestStr}.0`;

                const strikeSelect = document.getElementById('strikePrice');
                strikeSelect.value = strikeValue;
                // trigger change so expiries are loaded and option LTP fetched
                strikeSelect.dispatchEvent(new Event('change'));
            })
            .catch(err => {
                console.warn('Could not fetch underlying LTP to choose nearest strike', err);
            });
    }

</script>

</body>
</html>
