<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Place Order</title>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 2rem;
        }
        form {
            max-width: 600px;
        }
        label {
            display: block;
            margin-top: 1rem;
        }
        select, input {
            width: 100%;
            padding: 0.5rem;
        }
        button {
            margin-top: 1rem;
            padding: 0.5rem 1rem;
        }
        #result {
            margin-top: 1rem;
            font-weight: bold;
        }
        /* Inline edit row styling */
        .edit-row td {
            background: #f7f7f9;
        }
        .edit-input {
            width: 90px;
        }
        .small-btn {
            padding: 0.25rem 0.5rem;
            margin-left: 0.25rem;
        }
    </style>
</head>
<body>

<h2 style="display:flex;justify-content:space-between;align-items:center">Place Order <a href="/admin/dashboard" style="font-size:0.8rem;">Admin</a></h2>

<form id="placeOrderForm" method="POST">
    <label for="exchange">Exchange</label>
    <select id="exchange" name="exchange" required>
        <option value="">Select Exchange</option>
        <option value="NF">NF</option>
        <option value="BF">BF</option>
        <option value="MX">MX</option>
        <option value="NC">NC</option>
        <option value="BC">BC</option>
    </select>

    <label for="instrument">Instrument</label>
    <select id="instrument" name="instrument" required>
        <option value="">Select Instrument</option>
    </select>

    <label for="strikePrice">Strike Price</label>
    <select id="strikePrice" name="strikePrice">
        <option value="">Select Strike</option>
    </select>

    <label for="expiry">Expiry</label>
    <select id="expiry" name="expiry">
        <option value="">Select Expiry</option>
    </select>

    <label for="entryPrice">Entry Price</label>
    <input type="number" step="0.01" id="entryPrice" name="entryPrice" required>

    <label for="stopLoss">Stop Loss</label>
    <input type="number" step="0.01" id="stopLoss" name="stopLoss" required>

    <label for="target1">Target 1</label>
    <input type="number" step="0.01" id="target1" name="target1">

    <label for="target2">Target 2</label>
    <input type="number" step="0.01" id="target2" name="target2">

    <label for="target3">Target 3</label>
    <input type="number" step="0.01" id="target3" name="target3">

    <label for="optionType">Option Type</label>
    <select id="optionType" name="optionType">
        <option value="">--</option>
        <option value="CE">Call</option>
        <option value="PE">Put</option>
    </select>

    <label for="quantity">Quantity (Lots)</label>
    <input type="number" id="quantity" name="quantity" required th:default="1">

    <label for="userId">User ID (optional)</label>
    <input type="number" id="userId" name="userId" placeholder="e.g. 73196">

    <label>
        <input type="checkbox" id="intraday" name="intraday">
        Intraday
    </label>

    <button type="submit">Place Order</button>
</form>

<div id="result"></div>
<div style="margin-top:0.5rem;">
    <span id="handlerStatus" style="font-size:0.9rem;color:#666">Handler: initializing...</span>
    <button id="debugSubmitBtn" style="margin-left:8px;">Debug Submit</button>
</div>
<div id="last-refresh" style="margin-top:0.5rem;color:#666;font-size:0.9rem"></div>

<h3>Trading Requests</h3>
<table id="trading-requests-table" border="1" style="margin-bottom: 2rem; width: 100%;">
    <thead>
    <tr data-scrip="${order.scripCode}">
        <th>ID</th>
        <th>Symbol</th>
        <th>Exchange</th>
        <th>Strike</th>
        <th>Expiry</th>
        <th>Entry Price</th>
        <th>SL</th>
        <th>Target 1</th>
        <th>Qty</th>
        <th>OptionType</th>
        <th>Intraday</th>
        <th>Status</th>
        <th>Action</th>
        <th>LTP</th>
    </tr>
    </thead>
    <tbody></tbody>
</table>

<h3>Trades Executed</h3>
<table id="trades-executed-table" border="1" style="width: 100%;">
    <thead>
    <tr data-scrip="${setup.scripCode}" data-entry="${setup.entryPrice}" data-qty="${setup.quantity}">
        <th>ID</th>
        <th>Symbol</th>
        <th>Exchange</th>
        <th>Strike</th>
        <th>Expiry</th>
        <th>Entry Price</th>
        <th>SL</th>
        <th>Target 1</th>
        <th>Qty</th>
        <th>OptionType</th>
        <th>Intraday</th>
        <th>Status</th>
        <th>Action</th>
        <th>LTP</th> <!-- New -->
        <th>PnL</th> <!-- New -->
    </tr>
    </thead>
    <tbody></tbody>
</table>

<script>

    // Global error handlers so uncaught exceptions don't silently stop other JS
    window.addEventListener('error', function (ev) {
        console.error('Global error caught:', ev.error || ev.message, ev);
        const r = document.getElementById('result');
        if (r) r.innerText = 'JS error: ' + (ev.error?.message || ev.message || ev.error || 'unknown');
    });
    window.addEventListener('unhandledrejection', function (ev) {
        console.error('Unhandled promise rejection:', ev.reason);
        const r = document.getElementById('result');
        if (r) r.innerText = 'Unhandled promise rejection: ' + (ev.reason?.message || ev.reason);
    });

    const instrumentCache = {}; // { exchange: [symbols] }
    const strikeCache = {};     // { exchange_instrument: [strikes] }
    const ltpSocket = new WebSocket(`ws://${window.location.host}/ws/ltp`);
    const scripLtpMap = {}; // scripCode -> LTP
    const executedTrades = {}; // orderId -> { entryPrice, quantity }
    const requestMap = {};
    const executionMap = {};

    const lastKnownLTP = {};
    const lastKnownPNL = {};

    function updateLastRefresh() {
        const el = document.getElementById('last-refresh');
        if (el) el.innerText = 'Last refresh: ' + new Date().toLocaleTimeString();
    }

    // Utility: fetch with AbortController timeout to avoid hanging requests
    function fetchWithTimeout(url, opts = {}, timeoutMs = 6000) {
        const controller = new AbortController();
        const signal = controller.signal;
        const timer = setTimeout(() => controller.abort(), timeoutMs);
        return fetch(url, { ...opts, signal })
            .finally(() => clearTimeout(timer));
    }

    ltpSocket.onmessage = function (event) {
        const payload = JSON.parse(event.data);
        const scripCode = payload.scripCode;
        const ltp = payload.ltp;
        scripLtpMap[scripCode] = ltp;

        // üîÑ Update LTP and PnL in the UI
        updateTradingRequestLTP(scripCode, ltp);
        updateExecutedTradeLTP(scripCode, ltp);
    };

    // Helper to call backend MStock LTP endpoint for a qualified key like "NFO:CDSL25JAN2220CE"
    function fetchMStockLtpForKey(qualifiedKey) {
        if (!qualifiedKey) return Promise.resolve(null);
        const url = `/api/mstock/ltp?i=${encodeURIComponent(qualifiedKey)}`;
        return fetchWithTimeout(url)
            .then(res => res.json())
            .then(json => {
                if (!json || json.status !== 'success' || !json.data) return null;
                const entry = json.data[qualifiedKey];
                if (!entry) return null;
                // last_price may be integer or number string ‚Äî return numeric value
                return Number(entry.last_price);
            })
            .catch(err => {
                console.error('Failed to fetch MStock LTP for', qualifiedKey, err);
                return null;
            });
    }

    function updateTradingRequestLTP(scripCode, ltp) {
        const formatted = (ltp != null && !isNaN(ltp)) ? ltp.toFixed(2) : '-';
        document.querySelectorAll(`#trading-requests-table tbody tr`).forEach(row => {
            const cell = row.querySelector(`[data-scrip="${scripCode}"]`);
            if (!cell) return;
            if ((cell.innerText || '') !== formatted) cell.innerText = formatted;
        });
    }

    function updateExecutedTradeLTP(scripCode, ltp) {
         const scripKey = String(scripCode);
         lastKnownLTP[scripKey] = ltp;

         document.querySelectorAll('#trades-executed-table tbody tr').forEach(row => {
            // skip rejected or inactive (EXITED_SUCCESS) rows
            if (row.dataset.inactive === 'true' || row.dataset.rejected === 'true') return;
             const cell = row.querySelector(`[data-scrip="${scripKey}"]`);
             const pnlCell = row.querySelector(`[data-pnl="${scripKey}"]`);

             if (!cell || !pnlCell) return;

             const entry = parseFloat(row.dataset.entry) || 0;
             const qty = parseInt(row.dataset.qty) || 1;
             const pnl = (ltp - entry) * qty;
             lastKnownPNL[scripKey] = pnl;

             const ltpStr = (ltp != null && !isNaN(ltp)) ? ltp.toFixed(2) : '-';
             const pnlStr = isFinite(pnl) ? pnl.toFixed(0) : '-';

             if ((cell.textContent || '') !== ltpStr) cell.textContent = ltpStr;
             if ((pnlCell.textContent || '') !== pnlStr) {
                 pnlCell.textContent = pnlStr;
                 pnlCell.style.color = (Number(pnl) >= 0) ? 'green' : 'red';
             } else {
                 // Still ensure color is correct if value unchanged but sign might have changed (rare)
                 pnlCell.style.color = (Number(pnl) >= 0) ? 'green' : 'red';
             }
         });
     }



    // Fetch all symbols for NF, BF, NC and BC on page load
    function preloadInstruments() {
        ['NF', 'BF', 'NC', 'BC'].forEach(exchange => {
             const url = `/api/scripts/instruments/${encodeURIComponent(exchange)}`;
             console.debug('Preloading instruments from', url);
             fetchWithTimeout(url)
                 .then(res => {
                     if (!res.ok) throw new Error('HTTP ' + res.status + ' when fetching instruments for ' + exchange);
                     return res.json();
                 })
                 .then(data => {
                     instrumentCache[exchange] = Array.isArray(data?.instruments) ? data.instruments : [];
                     console.debug('Instruments cached for', exchange, instrumentCache[exchange].length);
                 })
                 .catch(err => {
                     console.error(`Failed to preload instruments for ${exchange}:`, err);
                     const r = document.getElementById('result');
                     if (r) r.innerText = `Failed to preload instruments for ${exchange}: ${err.message}`;
                 });
         });
     }

    // Load instruments when exchange is selected
    document.getElementById('exchange').addEventListener('change', function () {
        try {
            const exchange = this.value;
            console.debug('Exchange selected:', exchange);

            // Debug: show cache state
            try { console.debug('instrumentCache entry for', exchange, instrumentCache[exchange]); } catch (e) { console.debug('instrumentCache check failed', e); }

            const instrumentSelect = document.getElementById('instrument');
            instrumentSelect.innerHTML = '<option value="">Select Instrument</option>';

            if (!exchange) return;
            // Disable optionType for no-strike exchanges (NC/BC)
            const optionTypeSelect = document.getElementById('optionType');
            const exchUpper = (exchange || '').toUpperCase();
            const noStrikeExchanges = new Set(['NC','BC']);
            if (noStrikeExchanges.has(exchUpper)) {
                if (optionTypeSelect) {
                    optionTypeSelect.value = '';
                    optionTypeSelect.disabled = true;
                }
            } else {
                if (optionTypeSelect) optionTypeSelect.disabled = false;
            }

            // If we have cached instruments (non-empty) populate immediately so the UI is responsive.
            if (Array.isArray(instrumentCache[exchange]) && instrumentCache[exchange].length > 0) {
                console.debug('Using cached instruments for', exchange, '(populating immediately)');
                populateInstruments(instrumentCache[exchange]);
            }

            // Always fetch fresh from the API to ensure the latest data and to handle cases where preload returned empty.
            const url = `/api/scripts/instruments/${encodeURIComponent(exchange)}`;
            console.debug('Fetching instruments from (always):', url, 'cachePresent=', Array.isArray(instrumentCache[exchange]));
            fetchWithTimeout(url)
                .then(res => {
                    if (!res.ok) throw new Error('HTTP ' + res.status + ' when fetching instruments for ' + exchange);
                    return res.json();
                })
                .then(data => {
                    const instruments = Array.isArray(data?.instruments) ? data.instruments : [];
                    instrumentCache[exchange] = instruments; // üíæ Cache it
                    console.debug('Fetched instruments', instruments.length, 'for', exchange, '(post-fetch)');
                    if (instruments.length === 0) {
                        instrumentSelect.innerHTML = '<option value="">No instruments available</option>';
                        instrumentSelect.disabled = true;
                        document.getElementById('strikePrice').innerHTML = '<option value="">-</option>';
                        document.getElementById('strikePrice').disabled = true;
                        document.getElementById('expiry').innerHTML = '<option value="">-</option>';
                        document.getElementById('expiry').disabled = true;
                        document.getElementById('entryPrice').value = '';
                        return;
                    }
                    // ensure instrument select is enabled before populating
                    instrumentSelect.disabled = false;
                    populateInstruments(instruments);
                    // If this is a no-strike exchange, also ensure optionType is disabled (in case fetch changed state)
                    const optionTypeSelect2 = document.getElementById('optionType');
                    if (optionTypeSelect2) {
                        const exUp = (exchange || '').toUpperCase();
                        if (exUp === 'NC' || exUp === 'BC') {
                            optionTypeSelect2.value = '';
                            optionTypeSelect2.disabled = true;
                        } else {
                            optionTypeSelect2.disabled = false;
                        }
                    }
                 })
                .catch(err => {
                    console.error('Failed to load instruments:', err);
                    const r = document.getElementById('result');
                    if (r) r.innerText = `Failed to load instruments for ${exchange}: ${err.message}`;
                });
        } catch (e) {
            console.error('Exchange change handler failed', e);
            const r = document.getElementById('result'); if (r) r.innerText = 'Exchange handler error: ' + e.message;
        }
    });

    function populateInstruments(instruments) {
        const instrumentSelect = document.getElementById('instrument');
        const parent = instrumentSelect.parentNode;
        const existingSearch = document.getElementById('instrument-search');

        // Configuration: thresholds
        const RENDER_THRESHOLD = 500; // if more than this, show search box and render limited results
        const RENDER_LIMIT = 300;     // max number of options to render at a time

        // Helper to populate select quickly using innerHTML once
        function renderOptions(list) {
            instrumentSelect.disabled = false;
            let html = '<option value="">Select Instrument</option>';
            if (list && list.length) {
                // join string to avoid many DOM updates
                html += list.map(s => `<option value="${s}">${s}</option>`).join('');
            }
            instrumentSelect.innerHTML = html;
        }

        // Filter function used by search input
        function filterAndRender(q) {
            const term = (q || '').trim().toUpperCase();
            let matched = instruments;
            if (term) matched = instruments.filter(s => s.toUpperCase().includes(term));
            if (matched.length > RENDER_LIMIT) {
                // show only first RENDER_LIMIT matches
                renderOptions(matched.slice(0, RENDER_LIMIT));
                const r = document.getElementById('result');
                if (r) r.innerText = `${matched.length} matches ‚Äî showing first ${RENDER_LIMIT}. Keep typing to narrow.`;
            } else {
                renderOptions(matched);
                const r = document.getElementById('result'); if (r) r.innerText = '';
            }
        }

        // If the list is small, just render all options (fast path)
        if (!Array.isArray(instruments) || instruments.length === 0) {
            // empty
            if (existingSearch) existingSearch.remove();
            renderOptions([]);
            return;
        }

        if (instruments.length <= RENDER_THRESHOLD) {
            // remove any existing search UI
            if (existingSearch) existingSearch.remove();
            renderOptions(instruments);
            const r = document.getElementById('result'); if (r) r.innerText = '';
            return;
        }

        // Large list: show a search input (create if missing)
        let searchEl = existingSearch;
        if (!searchEl) {
            searchEl = document.createElement('input');
            searchEl.id = 'instrument-search';
            searchEl.type = 'search';
            searchEl.placeholder = `Type to filter ${instruments.length} instruments...`;
            searchEl.style.width = '100%';
            searchEl.style.marginBottom = '0.5rem';
            parent.insertBefore(searchEl, instrumentSelect);
            // listen for input and debounce
            let debounceTimer = null;
            searchEl.addEventListener('input', function () {
                clearTimeout(debounceTimer);
                const v = this.value;
                debounceTimer = setTimeout(() => filterAndRender(v), 150);
            });
        } else {
            searchEl.placeholder = `Type to filter ${instruments.length} instruments...`;
            searchEl.value = '';
        }

        // initial render: first N instruments (no filter)
        filterAndRender('');
     }

    // Resolve option trading symbol (and scripCode) for the given selection using backend lookup
    function resolveOptionTradingSymbol(exchange, instrument, strikePrice, optionType, expiry) {
        const params = new URLSearchParams();
        params.set('exchange', exchange);
        params.set('instrument', instrument);
        params.set('strikePrice', strikePrice);
        params.set('optionType', optionType);
        params.set('expiry', expiry);

        return fetchWithTimeout(`/api/scripts/option?${params.toString()}`)
            .then(res => { if (!res.ok) return null; return res.json(); })
             .then json => {
                 // expected { tradingSymbol: '...', scripCode: 12345 }
                 return json;
             })
             .catch(err => {
                console.error('Failed to resolve option trading symbol', err);
                return null;
            });
    }

    function buildQualifiedOptionKey(exchange, symbol, expiryStr, strike, optionType) {
        if (!exchange || !symbol || !expiryStr || !strike || !optionType) return null;

        const exchangeMap = {
            'NF': 'NFO',
            'BF': 'BFO'
        };
        const mappedExchange = exchangeMap[exchange] || exchange;

        // Custom month letter mapping based on your provided scheme
        function monthNumToLetter(m) {
            const monthLetterMap = {
                1: 'J',  // JAN
                2: 'F',  // FEB
                3: 'M',  // MAR
                4: 'A',  // APR
                5: 'M',  // MAY
                6: 'J',  // JUN
                7: 'J',  // JUL
                8: 'A',  // AUG
                9: 'S',  // SEP
                10: 'O', // OCT
                11: 'N', // NOV
                12: 'D'  // DEC
            };
            return monthLetterMap[m] || 'X';
        }

        // Parse expiry string to Date object
        let expiryDate = null;
        if (expiryStr.includes('/')) {
            const parts = expiryStr.split('/').map(s => s.trim());
            if (parts.length === 3) {
                const day = Number(parts[0]);
                const month = Number(parts[1]) - 1;
                const year = Number(parts[2]);
                expiryDate = new Date(year, month, day);
            }
        } else {
            const norm = expiryStr.replace(/[^0-9]/g, '');
            if (norm.length === 8) {
                const year = Number(norm.substring(0,4));
                const month = Number(norm.substring(4,6)) - 1;
                const day = Number(norm.substring(6,8));
                expiryDate = new Date(year, month, day);
            }
        }

        if (!expiryDate || isNaN(expiryDate.getTime())) {
            console.warn('Invalid expiry date format', expiryStr);
            return null;
        }

        const year = expiryDate.getFullYear();
        const month = expiryDate.getMonth();

        // Find last expiry day in the month for a given weekday
        function getLastExpiryDay(y, m, expiryWeekday) {
            const lastDay = new Date(y, m + 1, 0);
            const lastDate = lastDay.getDate();
            for(let d = lastDate; d > lastDate - 7; d--) {
                const date = new Date(y, m, d);
                if (date.getDay() === expiryWeekday) return date;
            }
            return null;
        }

        // Weekly expiry weekday by symbol: Sunday=0 ... Tuesday=2, Thursday=4
        let weeklyExpiryDay = null;
        if(symbol === 'NIFTY') weeklyExpiryDay = 2; // Tuesday
        else if(symbol === 'SENSEX') weeklyExpiryDay = 4; // Thursday
        else weeklyExpiryDay = 4; // Default to Thursday

        const lastExpiry = getLastExpiryDay(year, month, weeklyExpiryDay);

        // Is weekly expiry if expiryDate is on weeklyExpiryDay AND not the last expiry of the month
        const isWeekly = expiryDate.getDay() === weeklyExpiryDay &&
            expiryDate.getDate() !== lastExpiry.getDate();

        let expiryFormatted = '';
        if (isWeekly) {
            const yy = String(year).slice(-2);
            const monLetter = monthNumToLetter(month + 1);
            const dd = expiryDate.getDate().toString().padStart(2, '0');
            expiryFormatted = `${yy}${monLetter}${dd}`;
        } else {
            const yy = String(year).slice(-2);
            const monthNames = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
            expiryFormatted = `${yy}${monthNames[month]}`;
        }

        // Format strike, removing trailing decimal if whole number
        const strikeNum = Number(strike);
        const strikeStr = strikeNum % 1 === 0 ? `${strikeNum}` : strikeNum.toFixed(1);

        return `${mappedExchange}:${symbol}${expiryFormatted}${strikeStr}${optionType}`;
    }



    // Load strikes and expiries when instrument is selected
    // When instrument is selected, load (or use cached) strikes
    document.getElementById('instrument').addEventListener('change', function () {
        const exchange = document.getElementById('exchange').value;
        const instrument = this.value;

        if (!exchange || !instrument) return;

        const noStrikeExchanges = new Set(['NC','BC']);
        const isNoStrike = noStrikeExchanges.has((exchange || '').toUpperCase());

        if (isNoStrike) {
            // disable strike and expiry UI and fetch underlying LTP for the instrument
            const strikeSelect = document.getElementById('strikePrice');
            strikeSelect.innerHTML = `<option value="">-</option>`;
            strikeSelect.value = '';
            strikeSelect.disabled = true;

            const expirySelect = document.getElementById('expiry');
            expirySelect.innerHTML = `<option value="">-</option>`;
            expirySelect.value = '';
            expirySelect.disabled = true;

            // fetch underlying LTP and set as entry price (map NF->NSE, BF->BSE as before)
            const underlyingExchangeMap = { 'NF': 'NSE', 'BF': 'BSE', 'NC': 'NSE', 'BC': 'BSE' };
            const mappedExchange = underlyingExchangeMap[exchange] || exchange;
            const qualified = `${mappedExchange}:${instrument}`;
            fetchMStockLtpForKey(qualified).then(ltp => {
                if (ltp != null) document.getElementById('entryPrice').value = ltp;
            }).catch(err => console.warn('Failed to fetch underlying LTP for instrument', err));
            return;
        }

        const cacheKey = `${exchange}_${instrument}`;
        if (strikeCache[cacheKey]) {
            populateStrikeDropdown(strikeCache[cacheKey]);
            // after populating strikes from cache, fetch underlying LTP and pick nearest strike (if strikes cached)
            fetchUnderlyingAndSelectNearestStrike(exchange, instrument, strikeCache[cacheKey]);
        } else {
            fetchWithTimeout(`/api/scripts/strikes?exchange=${encodeURIComponent(exchange)}&instrument=${encodeURIComponent(instrument)}`)
                .then(res => res.json())
                .then(data => {
                    const strikes = data.strikes || [];
                    strikeCache[cacheKey] = strikes;
                    populateStrikeDropdown(strikes);
                    // after caching strikes, fetch underlying LTP and select nearest
                    fetchUnderlyingAndSelectNearestStrike(exchange, instrument, strikes);
                })
                .catch(err => {
                    console.error("Failed to load strikes:", err);
                });
        }
    });

    // Auto-select middle strike
    function populateStrikeDropdown(strikes) {
        const strikeSelect = document.getElementById('strikePrice');
        strikeSelect.innerHTML = '<option value="">Select Strike</option>';

        strikes.forEach(strike => {
            strikeSelect.innerHTML += `<option value="${strike}">${strike}</option>`;
        });

        // Do NOT auto-select the middle strike here. Nearest strike will be selected
        // by fetchUnderlyingAndSelectNearestStrike after we fetch the underlying LTP.
        autoSelectOptionTypeIfValid();
    }

    document.getElementById('strikePrice').addEventListener('change', function () {
        autoSelectOptionTypeIfValid();
    });

    // Load expiries when strike is selected
    document.getElementById('strikePrice').addEventListener('change', function () {
        const exchange = document.getElementById('exchange').value;
        const instrument = document.getElementById('instrument').value;
        const strikePrice = this.value;

        if (!exchange || !instrument || !strikePrice) return;

        fetchWithTimeout(`/api/scripts/expiries?exchange=${encodeURIComponent(exchange)}&instrument=${encodeURIComponent(instrument)}&strikePrice=${encodeURIComponent(strikePrice)}`)
            .then(res => res.json())
            .then(data => {
                const expiries = data.expiries || [];
                const expirySelect = document.getElementById('expiry');
                expirySelect.innerHTML = '<option value="">Select Expiry</option>';

                expiries.forEach((expiry, index) => {
                    const selected = index === 0 ? 'selected' : '';
                    expirySelect.innerHTML += `<option value="${expiry}" ${selected}>${expiry}</option>`;
                });

                // after expiry and optionType are set, resolve and fetch option LTP to populate entry price
                const selectedExpiry = expirySelect.value;
                const optionType = document.getElementById('optionType').value || 'CE';

                if (selectedExpiry) {
                    // Build qualified option key per requested format and fetch LTP directly
                    const qualifiedKey = buildQualifiedOptionKey(exchange, instrument, selectedExpiry, strikePrice, optionType);
                    if (qualifiedKey) {
                        fetchMStockLtpForKey(qualifiedKey).then(ltp => {
                            if (ltp != null) {
                                document.getElementById('entryPrice').value = ltp;
                            }
                        });
                    }
                }

            })
            .catch(err => {
                console.error("Failed to load expiries:", err);
            });
    });

    // Whenever expiry or option type changes, re-resolve option trading symbol and populate entry price
    function fetchOptionLtpAndPopulateEntry() {
        const exchange = document.getElementById('exchange').value;
        const instrument = document.getElementById('instrument').value;
        const strikePrice = document.getElementById('strikePrice').value;
        const optionType = document.getElementById('optionType').value || 'CE';
        const expiry = document.getElementById('expiry').value;

        const noStrikeExchanges = new Set(['NC','BC']);
        const isNoStrike = noStrikeExchanges.has((exchange || '').toUpperCase());

        // For NC/BC exchanges, fetch underlying LTP directly
        if (isNoStrike) {
            if (!exchange || !instrument) return;
            const underlyingExchangeMap = { 'NF': 'NSE', 'BF': 'BSE', 'NC': 'NSE', 'BC': 'BSE' };
            const mappedExchange = underlyingExchangeMap[exchange] || exchange;
            const qualified = `${mappedExchange}:${instrument}`;
            fetchMStockLtpForKey(qualified)
                .then(ltp => { if (ltp != null) document.getElementById('entryPrice').value = ltp; })
                .catch(err => console.warn('Failed to fetch underlying LTP for instrument', err));
            return;
        }

        if (!exchange || !instrument || !strikePrice || !expiry) return;

        const qualifiedKey = buildQualifiedOptionKey(exchange, instrument, expiry, strikePrice, optionType);
        if (!qualifiedKey) return;
        fetchMStockLtpForKey(qualifiedKey)
            .then(ltp => {
                if (ltp != null) {
                    document.getElementById('entryPrice').value = ltp;
                }
            })
            .catch(err => console.warn('Failed to fetch option LTP', err));
    }

    document.getElementById('expiry').addEventListener('change', function () {
        fetchOptionLtpAndPopulateEntry();
    });

    document.getElementById('optionType').addEventListener('change', function () { fetchOptionLtpAndPopulateEntry(); });

    // Submit form via REST - attach after DOM ready
    function attachFormHandlers() {
         const form = document.getElementById('placeOrderForm');
+        // If page opened with ?userId=... (e.g. inside admin iframe), pre-fill userId input and disable it
+        try {
+            const params = new URLSearchParams(window.location.search || '');
+            const uid = params.get('userId');
+            if (uid) {
+                try {
+                    const userInput = document.getElementById('userId');
+                    if (userInput) {
+                        userInput.value = uid;
+                        // mark readonly so admin cannot accidentally change user mapping inside iframe
+                        userInput.disabled = true;
+                        userInput.setAttribute('data-prefilled-from-query', 'true');
+                    }
+                } catch (e) { console.debug('prefill userId from query failed', e); }
+            }
+        } catch (e) { console.debug('parse querystring failed', e); }

        function buildPayload(formEl) {
            const exch = (formEl.exchange && formEl.exchange.value) ? formEl.exchange.value.toUpperCase() : '';
            const noStrikeExchanges = new Set(['NC','BC']);
            const isNoStrike = noStrikeExchanges.has(exch);
            return {
                exchange: formEl.exchange.value,
                instrument: formEl.instrument.value,
                strikePrice: isNoStrike ? null : (formEl.strikePrice.value ? parseFloat(formEl.strikePrice.value) : null),
                expiry: isNoStrike ? null : (formEl.expiry.value || null),
                entryPrice: parseFloat(formEl.entryPrice.value),
                stopLoss: parseFloat(formEl.stopLoss.value),
                target1: parseFloat(formEl.target1.value) || 0,
                target2: parseFloat(formEl.target2.value) || 0,
                target3: parseFloat(formEl.target3.value) || 0,
                optionType: isNoStrike ? '' : (formEl.optionType.value || null),
                quantity: parseInt(formEl.quantity.value),
                intraday: formEl.intraday.checked,
                userId: formEl.userId && formEl.userId.value ? parseInt(formEl.userId.value) : null
            };
        }

        async function submitPlaceOrder(evt) {
            try {
                if (evt && evt.preventDefault) evt.preventDefault();
                const payload = buildPayload(form);
                console.log('submitPlaceOrder invoked', payload);

                // prepare headers
                const headers = { 'Content-Type': 'application/json', 'X-Requested-With': 'XMLHttpRequest' };
                try {
                    const csrfMeta = document.querySelector('meta[name="_csrf"]');
                    const csrfHeaderMeta = document.querySelector('meta[name="_csrf_header"]');
                    if (csrfMeta && csrfHeaderMeta) {
                        headers[csrfHeaderMeta.getAttribute('content') || csrfHeaderMeta.content] = csrfMeta.getAttribute('content') || csrfMeta.content;
                    } else {
                        function getCookie(name) { const v = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)'); return v ? v.pop() : null; }
                        const token = getCookie('XSRF-TOKEN') || getCookie('X-CSRF-TOKEN');
                        if (token) headers['X-CSRF-TOKEN'] = token;
                    }
                } catch (e) { console.debug('CSRF attach failed', e); }

                window.lastPlaceOrderPayload = payload; // expose for debugging

                const resp = await fetch('/api/trades/trigger-on-price', {
                    method: 'POST',
                    credentials: 'include',
                    headers,
                    body: JSON.stringify(payload)
                });
                const txt = await resp.text().catch(() => '');
                console.log('trigger-on-price returned', resp.status, txt);
                if (!resp.ok) throw new Error(`HTTP ${resp.status} ${txt}`);

                const rEl = document.getElementById('result'); if (rEl) rEl.innerText = '‚úÖ Order Triggered';
                // notify parent
                try {
                    const sentUserId = payload.userId || null;
                    if (window.parent && window.parent !== window && typeof window.parent.postMessage === 'function') {
                        window.parent.postMessage({ type: 'orderTriggered', userId: sentUserId }, window.location.origin);
                    }
                } catch (pe) { console.debug('postMessage failed', pe); }

                form.reset();
                loadRequestedOrders();
            } catch (err) {
                console.error('submitPlaceOrder error', err);
                const rEl = document.getElementById('result'); if (rEl) r.innerText = '‚ùå Failed to trigger order: ' + (err.message || err);
            }
        }

        // attach handlers and expose globally for debugging
        try {
            if (!form) {
                console.warn('placeOrderForm not found in DOM; handlers not attached yet');
                const hs = document.getElementById('handlerStatus'); if (hs) hs.innerText = 'Handler: no form present';
                window.placeOrderHandlerAttached = false;
                return;
            }
            form.addEventListener('submit', submitPlaceOrder);
            const submitBtn = form.querySelector('button[type="submit"]');
            if (submitBtn) submitBtn.addEventListener('click', submitPlaceOrder);
            window.submitPlaceOrder = submitPlaceOrder;
            window.placeOrderHandlerAttached = true;
            console.log('Place order handlers attached');
            // Update handler status UI
            const hs = document.getElementById('handlerStatus'); if (hs) hs.innerText = 'Handler: attached';
            // Debug button
            try {
                const dbg = document.getElementById('debugSubmitBtn');
                if (dbg) dbg.addEventListener('click', function () {
                    if (typeof window.submitPlaceOrder === 'function') {
                        console.log('Debug Submit invoked');
                        window.submitPlaceOrder();
                    } else {
                        alert('submitPlaceOrder() not available - check console for errors');
                    }
                });
            } catch (e) { console.debug('failed to attach debug button', e); }
        } catch (e) {
            console.error('Failed to attach place order handlers', e);
            try { const hs = document.getElementById('handlerStatus'); if (hs) hs.innerText = 'Handler: failed'; } catch (ee) {}
        }
    }

    // Attach when DOM ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', attachFormHandlers);
    } else {
        attachFormHandlers();
    }
***
