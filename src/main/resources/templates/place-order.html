<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Place Order</title>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 2rem;
        }
        form {
            max-width: 600px;
        }
        label {
            display: block;
            margin-top: 1rem;
        }
        select, input {
            width: 100%;
            padding: 0.5rem;
        }
        button {
            margin-top: 1rem;
            padding: 0.5rem 1rem;
        }
        #result {
            margin-top: 1rem;
            font-weight: bold;
        }
        /* Inline edit row styling */
        .edit-row td {
            background: #f7f7f9;
        }
        .edit-input {
            width: 90px;
        }
        .small-btn {
            padding: 0.25rem 0.5rem;
            margin-left: 0.25rem;
        }
    </style>
</head>
<body>

<h2>Place Order</h2>

<form id="placeOrderForm" method="POST">
    <label for="exchange">Exchange</label>
    <select id="exchange" name="exchange" required>
        <option value="">Select Exchange</option>
        <option value="NF">NF</option>
        <option value="BF">BF</option>
        <option value="MX">MX</option>
        <option value="NC">NC</option>
        <option value="BF">BF</option>
    </select>

    <label for="instrument">Instrument</label>
    <select id="instrument" name="instrument" required>
        <option value="">Select Instrument</option>
    </select>

    <label for="strikePrice">Strike Price</label>
    <select id="strikePrice" name="strikePrice">
        <option value="">Select Strike</option>
    </select>

    <label for="expiry">Expiry</label>
    <select id="expiry" name="expiry">
        <option value="">Select Expiry</option>
    </select>

    <label for="entryPrice">Entry Price</label>
    <input type="number" step="0.01" id="entryPrice" name="entryPrice" required>

    <label for="stopLoss">Stop Loss</label>
    <input type="number" step="0.01" id="stopLoss" name="stopLoss" required>

    <label for="target1">Target 1</label>
    <input type="number" step="0.01" id="target1" name="target1">

    <label for="target2">Target 2</label>
    <input type="number" step="0.01" id="target2" name="target2">

    <label for="target3">Target 3</label>
    <input type="number" step="0.01" id="target3" name="target3">

    <label for="optionType">Option Type</label>
    <select id="optionType" name="optionType">
        <option value="">--</option>
        <option value="CE">Call</option>
        <option value="PE">Put</option>
    </select>

    <label for="quantity">Quantity (Lots)</label>
    <input type="number" id="quantity" name="quantity" required th:default="1">

    <label>
        <input type="checkbox" id="intraday" name="intraday">
        Intraday
    </label>

    <button type="submit">Place Order</button>
</form>

<div id="result"></div>

<h3>Trading Requests</h3>
<table id="trading-requests-table" border="1" style="margin-bottom: 2rem; width: 100%;">
    <thead>
    <tr data-scrip="${order.scripCode}">
        <th>ID</th>
        <th>Symbol</th>
        <th>Exchange</th>
        <th>Strike</th>
        <th>Expiry</th>
        <th>Entry Price</th>
        <th>SL</th>
        <th>Target 1</th>
        <th>Qty</th>
        <th>OptionType</th>
        <th>Intraday</th>
        <th>Status</th>
        <th>Action</th>
        <th>LTP</th>
    </tr>
    </thead>
    <tbody></tbody>
</table>

<h3>Trades Executed</h3>
<table id="trades-executed-table" border="1" style="width: 100%;">
    <thead>
    <tr data-scrip="${setup.scripCode}" data-entry="${setup.entryPrice}" data-qty="${setup.quantity}">
        <th>ID</th>
        <th>Symbol</th>
        <th>Exchange</th>
        <th>Strike</th>
        <th>Expiry</th>
        <th>Entry Price</th>
        <th>SL</th>
        <th>Target 1</th>
        <th>Qty</th>
        <th>OptionType</th>
        <th>Intraday</th>
        <th>Status</th>
        <th>Action</th>
        <th>LTP</th> <!-- New -->
        <th>PnL</th> <!-- New -->
    </tr>
    </thead>
    <tbody></tbody>
</table>

<script>

    const instrumentCache = {}; // { exchange: [symbols] }
    const strikeCache = {};     // { exchange_instrument: [strikes] }
    const ltpSocket = new WebSocket(`ws://${window.location.host}/ws/ltp`);
    const scripLtpMap = {}; // scripCode -> LTP
    const executedTrades = {}; // orderId -> { entryPrice, quantity }
    const requestMap = {};
    const executionMap = {};

    const lastKnownLTP = {};
    const lastKnownPNL = {};

    ltpSocket.onmessage = function (event) {
        const payload = JSON.parse(event.data);
        const scripCode = payload.scripCode;
        const ltp = payload.ltp;
        scripLtpMap[scripCode] = ltp;

        // üîÑ Update LTP and PnL in the UI
        updateTradingRequestLTP(scripCode, ltp);
        updateExecutedTradeLTP(scripCode, ltp);
    };

    // Helper to call backend MStock LTP endpoint for a qualified key like "NFO:CDSL25JAN2220CE"
    function fetchMStockLtpForKey(qualifiedKey) {
        if (!qualifiedKey) return Promise.resolve(null);
        const url = `/api/mstock/ltp?i=${encodeURIComponent(qualifiedKey)}`;
        return fetch(url)
            .then(res => res.json())
            .then(json => {
                if (!json || json.status !== 'success' || !json.data) return null;
                const entry = json.data[qualifiedKey];
                if (!entry) return null;
                // last_price may be integer or number string ‚Äî return numeric value
                return Number(entry.last_price);
            })
            .catch(err => {
                console.error('Failed to fetch MStock LTP for', qualifiedKey, err);
                return null;
            });
    }

    function updateTradingRequestLTP(scripCode, ltp) {
        document.querySelectorAll(`#trading-requests-table tbody tr`).forEach(row => {
            const cell = row.querySelector(`[data-scrip="${scripCode}"]`);
            if (cell) cell.innerText = ltp.toFixed(2);
        });
    }

    function updateExecutedTradeLTP(scripCode, ltp) {
         const scripKey = String(scripCode);
         lastKnownLTP[scripKey] = ltp;

         document.querySelectorAll('#trades-executed-table tbody tr').forEach(row => {
            // skip rejected rows
            if (row.dataset.rejected === 'true') return;
             const cell = row.querySelector(`[data-scrip="${scripKey}"]`);
             const pnlCell = row.querySelector(`[data-pnl="${scripKey}"]`);

             if (cell && pnlCell) {
                 const entry = parseFloat(row.dataset.entry) || 0;
                 const qty = parseInt(row.dataset.qty) || 1;
                 const pnl = (ltp - entry) * qty;
                 lastKnownPNL[scripKey] = pnl;

                 cell.textContent = ltp.toFixed(2);
                 pnlCell.textContent = pnl.toFixed(0);
                 pnlCell.style.color = pnl >= 0 ? "green" : "red";
             }
         });
     }



    // Fetch all symbols for NF and BF on page load
    function preloadInstruments() {
        ['NF', 'BF'].forEach(exchange => {
            const url = `/api/scripts/instruments/${encodeURIComponent(exchange)}`;
            console.debug('Preloading instruments from', url);
            fetch(url)
                .then(res => {
                    if (!res.ok) throw new Error('HTTP ' + res.status + ' when fetching instruments for ' + exchange);
                    return res.json();
                })
                .then(data => {
                    instrumentCache[exchange] = Array.isArray(data?.instruments) ? data.instruments : [];
                    console.debug('Instruments cached for', exchange, instrumentCache[exchange].length);
                })
                .catch(err => {
                    console.error(`Failed to preload instruments for ${exchange}:`, err);
                    const r = document.getElementById('result');
                    if (r) r.innerText = `Failed to preload instruments for ${exchange}: ${err.message}`;
                });
        });
    }

    // Load instruments when exchange is selected
    document.getElementById('exchange').addEventListener('change', function () {
        const exchange = this.value;
        console.debug('Exchange selected:', exchange);

        const instrumentSelect = document.getElementById('instrument');
        instrumentSelect.innerHTML = '<option value="">Select Instrument</option>';

        if (!exchange) return;
        if (Array.isArray(instrumentCache[exchange]) && instrumentCache[exchange].length > 0) {
            // ‚úÖ Already cached
            console.debug('Using cached instruments for', exchange);
            populateInstruments(instrumentCache[exchange]);
            // also fetch underlying LTP and auto-select nearest strike (if strikes cached)
            const cacheKey = `${exchange}_${instrumentSelect.value}`;
            if (strikeCache[cacheKey]) {
                fetchUnderlyingAndSelectNearestStrike(exchange, instrumentSelect.value, strikeCache[cacheKey]);
            }
        } else {
            // ‚ùå Not cached ‚Äì fetch and cache
            const url = `/api/scripts/instruments/${encodeURIComponent(exchange)}`;
            console.debug('Fetching instruments from', url);
            fetch(url)
                .then(res => {
                    if (!res.ok) throw new Error('HTTP ' + res.status + ' when fetching instruments for ' + exchange);
                    return res.json();
                })
                .then(data => {
                    const instruments = Array.isArray(data?.instruments) ? data.instruments : [];
                    instrumentCache[exchange] = instruments; // üíæ Cache it
                    console.debug('Fetched instruments', instruments.length, 'for', exchange);
                    populateInstruments(instruments);
                })
                .catch(err => {
                    console.error("Failed to load instruments:", err);
                    const r = document.getElementById('result');
                    if (r) r.innerText = `Failed to load instruments for ${exchange}: ${err.message}`;
                });
        }
    });

    function populateInstruments(instruments) {
        const instrumentSelect = document.getElementById('instrument');
        instrumentSelect.innerHTML = '<option value="">Select Instrument</option>';
        instruments.forEach(symbol => {
            instrumentSelect.innerHTML += `<option value="${symbol}">${symbol}</option>`;
        });
    }

    // Resolve option trading symbol (and scripCode) for the given selection using backend lookup
    function resolveOptionTradingSymbol(exchange, instrument, strikePrice, optionType, expiry) {
        const params = new URLSearchParams();
        params.set('exchange', exchange);
        params.set('instrument', instrument);
        params.set('strikePrice', strikePrice);
        params.set('optionType', optionType);
        params.set('expiry', expiry);

        return fetch(`/api/scripts/option?${params.toString()}`)
            .then(res => {
                if (!res.ok) return null;
                return res.json();
            })
            .then(json => {
                // expected { tradingSymbol: '...', scripCode: 12345 }
                return json;
            })
            .catch(err => {
                console.error('Failed to resolve option trading symbol', err);
                return null;
            });
    }

    function buildQualifiedOptionKey(exchange, symbol, expiryStr, strike, optionType) {
        if (!exchange || !symbol || !expiryStr || !strike || !optionType) return null;

        const exchangeMap = {
            'NF': 'NFO',
            'BF': 'BFO'
        };
        const mappedExchange = exchangeMap[exchange] || exchange;

        // Custom month letter mapping based on your provided scheme
        function monthNumToLetter(m) {
            const monthLetterMap = {
                1: 'J',  // JAN
                2: 'F',  // FEB
                3: 'M',  // MAR
                4: 'A',  // APR
                5: 'M',  // MAY
                6: 'J',  // JUN
                7: 'J',  // JUL
                8: 'A',  // AUG
                9: 'S',  // SEP
                10: 'O', // OCT
                11: 'N', // NOV
                12: 'D'  // DEC
            };
            return monthLetterMap[m] || 'X';
        }

        // Parse expiry string to Date object
        let expiryDate = null;
        if (expiryStr.includes('/')) {
            const parts = expiryStr.split('/').map(s => s.trim());
            if (parts.length === 3) {
                const day = Number(parts[0]);
                const month = Number(parts[1]) - 1;
                const year = Number(parts[2]);
                expiryDate = new Date(year, month, day);
            }
        } else {
            const norm = expiryStr.replace(/[^0-9]/g, '');
            if (norm.length === 8) {
                const year = Number(norm.substring(0,4));
                const month = Number(norm.substring(4,6)) - 1;
                const day = Number(norm.substring(6,8));
                expiryDate = new Date(year, month, day);
            }
        }

        if (!expiryDate || isNaN(expiryDate.getTime())) {
            console.warn('Invalid expiry date format', expiryStr);
            return null;
        }

        const year = expiryDate.getFullYear();
        const month = expiryDate.getMonth();

        // Find last expiry day in the month for a given weekday
        function getLastExpiryDay(y, m, expiryWeekday) {
            const lastDay = new Date(y, m + 1, 0);
            const lastDate = lastDay.getDate();
            for(let d = lastDate; d > lastDate - 7; d--) {
                const date = new Date(y, m, d);
                if (date.getDay() === expiryWeekday) return date;
            }
            return null;
        }

        // Weekly expiry weekday by symbol: Sunday=0 ... Tuesday=2, Thursday=4
        let weeklyExpiryDay = null;
        if(symbol === 'NIFTY') weeklyExpiryDay = 2; // Tuesday
        else if(symbol === 'SENSEX') weeklyExpiryDay = 4; // Thursday
        else weeklyExpiryDay = 4; // Default to Thursday

        const lastExpiry = getLastExpiryDay(year, month, weeklyExpiryDay);

        // Is weekly expiry if expiryDate is on weeklyExpiryDay AND not the last expiry of the month
        const isWeekly = expiryDate.getDay() === weeklyExpiryDay &&
            expiryDate.getDate() !== lastExpiry.getDate();

        let expiryFormatted = '';
        if (isWeekly) {
            const yy = String(year).slice(-2);
            const monLetter = monthNumToLetter(month + 1);
            const dd = expiryDate.getDate().toString().padStart(2, '0');
            expiryFormatted = `${yy}${monLetter}${dd}`;
        } else {
            const yy = String(year).slice(-2);
            const monthNames = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
            expiryFormatted = `${yy}${monthNames[month]}`;
        }

        // Format strike, removing trailing decimal if whole number
        const strikeNum = Number(strike);
        const strikeStr = strikeNum % 1 === 0 ? `${strikeNum}` : strikeNum.toFixed(1);

        return `${mappedExchange}:${symbol}${expiryFormatted}${strikeStr}${optionType}`;
    }



    // Load strikes and expiries when instrument is selected
    // When instrument is selected, load (or use cached) strikes
    document.getElementById('instrument').addEventListener('change', function () {
        const exchange = document.getElementById('exchange').value;
        const instrument = this.value;

        if (!exchange || !instrument) return;

        const cacheKey = `${exchange}_${instrument}`;
        if (strikeCache[cacheKey]) {
            populateStrikeDropdown(strikeCache[cacheKey]);
            // after populating strikes from cache, fetch underlying LTP and pick nearest strike
            fetchUnderlyingAndSelectNearestStrike(exchange, instrument, strikeCache[cacheKey]);
        } else {
            fetch(`/api/scripts/strikes?exchange=${encodeURIComponent(exchange)}&instrument=${encodeURIComponent(instrument)}`)
                .then(res => res.json())
                .then(data => {
                    const strikes = data.strikes || [];
                    strikeCache[cacheKey] = strikes;
                    populateStrikeDropdown(strikes);
                    // after caching strikes, fetch underlying LTP and select nearest
                    fetchUnderlyingAndSelectNearestStrike(exchange, instrument, strikes);
                })
                .catch(err => {
                    console.error("Failed to load strikes:", err);
                });
        }
    });

    // Auto-select middle strike
    function populateStrikeDropdown(strikes) {
        const strikeSelect = document.getElementById('strikePrice');
        strikeSelect.innerHTML = '<option value="">Select Strike</option>';

        strikes.forEach(strike => {
            strikeSelect.innerHTML += `<option value="${strike}">${strike}</option>`;
        });

        // Do NOT auto-select the middle strike here. Nearest strike will be selected
        // by fetchUnderlyingAndSelectNearestStrike after we fetch the underlying LTP.
        autoSelectOptionTypeIfValid();
    }

    document.getElementById('strikePrice').addEventListener('change', function () {
        autoSelectOptionTypeIfValid();
    });

    // Load expiries when strike is selected
    document.getElementById('strikePrice').addEventListener('change', function () {
        const exchange = document.getElementById('exchange').value;
        const instrument = document.getElementById('instrument').value;
        const strikePrice = this.value;

        if (!exchange || !instrument || !strikePrice) return;

        fetch(`/api/scripts/expiries?exchange=${encodeURIComponent(exchange)}&instrument=${encodeURIComponent(instrument)}&strikePrice=${encodeURIComponent(strikePrice)}`)
            .then(res => res.json())
            .then(data => {
                const expiries = data.expiries || [];
                const expirySelect = document.getElementById('expiry');
                expirySelect.innerHTML = '<option value="">Select Expiry</option>';

                expiries.forEach((expiry, index) => {
                    const selected = index === 0 ? 'selected' : '';
                    expirySelect.innerHTML += `<option value="${expiry}" ${selected}>${expiry}</option>`;
                });

                // after expiry and optionType are set, resolve and fetch option LTP to populate entry price
                const selectedExpiry = expirySelect.value;
                const optionType = document.getElementById('optionType').value || 'CE';

                if (selectedExpiry) {
                    // Build qualified option key per requested format and fetch LTP directly
                    const qualifiedKey = buildQualifiedOptionKey(exchange, instrument, selectedExpiry, strikePrice, optionType);
                    if (qualifiedKey) {
                        fetchMStockLtpForKey(qualifiedKey).then(ltp => {
                            if (ltp != null) {
                                document.getElementById('entryPrice').value = ltp;
                            }
                        });
                    }
                }

            })
            .catch(err => {
                console.error("Failed to load expiries:", err);
            });
    });

    // Whenever expiry or option type changes, re-resolve option trading symbol and populate entry price
    function fetchOptionLtpAndPopulateEntry() {
        const exchange = document.getElementById('exchange').value;
        const instrument = document.getElementById('instrument').value;
        const strikePrice = document.getElementById('strikePrice').value;
        const optionType = document.getElementById('optionType').value || 'CE';
        const expiry = document.getElementById('expiry').value;

        if (!exchange || !instrument || !strikePrice || !expiry) return;

        const qualifiedKey = buildQualifiedOptionKey(exchange, instrument, expiry, strikePrice, optionType);
        if (!qualifiedKey) return;
        fetchMStockLtpForKey(qualifiedKey)
            .then(ltp => {
                if (ltp != null) {
                    document.getElementById('entryPrice').value = ltp;
                }
            })
            .catch(err => console.warn('Failed to fetch option LTP', err));
    }

    document.getElementById('expiry').addEventListener('change', function () {
        fetchOptionLtpAndPopulateEntry();
    });

    document.getElementById('optionType').addEventListener('change', function () {
        // when option type changes we may need to re-resolve symbol and fetch LTP
        fetchOptionLtpAndPopulateEntry();
    });

    // Submit form via REST
    document.getElementById('placeOrderForm').addEventListener('submit', function (e) {
        e.preventDefault();

        const form = e.target;
        const data = {
            exchange: form.exchange.value,
            instrument: form.instrument.value,
            strikePrice: form.strikePrice.value ? parseFloat(form.strikePrice.value):null,
            expiry: form.expiry.value || null,
            entryPrice: parseFloat(form.entryPrice.value),
            stopLoss: parseFloat(form.stopLoss.value),
            target1: parseFloat(form.target1.value) || 0,
            target2: parseFloat(form.target2.value) || 0,
            target3: parseFloat(form.target3.value) || 0,
            optionType: form.optionType.value || null,
            quantity: parseInt(form.quantity.value),
            intraday: form.intraday.checked
        };

        fetch('/api/trades/trigger-on-price', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(data)
        }).then(res => {
            if (!res.ok) throw new Error("Failed to trigger order");
            return res.text();
        }).then(msg => {
            document.getElementById('result').innerText = "‚úÖ Order Triggered";
            form.reset();
            loadRequestedOrders()
        }).catch(err => {
            document.getElementById('result').innerText = "‚ùå Failed to trigger order.";
            console.error(err);
        });
    });

    function autoSelectOptionTypeIfValid() {
        const instrument = document.getElementById('instrument').value;
        const strike = document.getElementById('strikePrice').value;

        if (instrument && strike) {
            document.getElementById('optionType').value = 'CE'; // Auto-select Call
        }
    }

    function cancelTradeRequest(id) {
        if (!confirm("Are you sure you want to cancel this trade request?")) return;

        fetch(`/api/trades/cancel-request/${id}`, {
            method: 'POST'
        }).then(res => {
            if (!res.ok) throw new Error("Cancel failed");
            return res.text();
        }).then(() => {
            alert("‚úÖ Trade request cancelled");
            loadRequestedOrders();
        }).catch(err => {
            console.error("‚ùå Cancel failed", err);
            alert("‚ùå Failed to cancel request");
        });
    }

    function squareOffTrade(id) {
        if (!confirm("Are you sure you want to square off this trade?")) return;

        fetch(`/api/trades/square-off/${id}`, {
            method: 'POST'
        }).then(res => {
            if (!res.ok) throw new Error("Square off failed");
            return res.text();
        }).then(() => {
            alert("‚úÖ Trade squared off");
            loadTradeSetups();
        }).catch(err => {
            console.error("‚ùå Square off failed", err);
            alert("‚ùå Failed to square off trade");
        });
    }

    function moveSLtoCost(id) {
        if (!confirm("Are you sure you want to move the sl to cost?")) return;


        fetch(`/api/trades/move-sl-to-cost/${id}`, {
            method: 'POST'
        }).then(res => {
            if (!res.ok) throw new Error("MoveSltoCost failed");
            return res.text();
        }).then(() => {
            alert("‚úÖ Sl Moved to Cost");
            loadTradeSetups();
        }).catch(err => {
            console.error("‚ùå Sl Cost failed", err);
            alert("‚ùå Failed to move sl to cost");
        });
    }

    // Inline edit helpers for Requests & Executions
    function createEditRow(columnsCount, id) {
        const tr = document.createElement('tr');
        tr.className = 'edit-row';
        tr.dataset.editingFor = id;
        // create TDs equal to columnsCount
        for (let i = 0; i < columnsCount; i++) {
            const td = document.createElement('td');
            tr.appendChild(td);
        }
        return tr;
    }

    function editRequest(id) {
        const order = requestMap[id];
        if (!order) {
            alert('Trade request data not available locally. Refreshing requests.');
            loadRequestedOrders();
            return;
        }
        // remove any existing edit row
        cancelEditRow();

        const tbody = document.querySelector('#trading-requests-table tbody');
        // find row by data-id attribute (more robust than matching innerText)
        const row = tbody.querySelector(`tr[data-id="${id}"]`);
        const headerRow = document.querySelector('#trading-requests-table thead tr');
        const columnsCount = headerRow ? headerRow.children.length : 14; // fallback to 14 columns if header not found
        const editRow = createEditRow(columnsCount, 'req_' + id);

        // build inputs for SL, target1, target2, target3 and intraday and save/cancel buttons
        editRow.children[0].innerText = '';
        editRow.children[1].innerText = order.symbol || '';
        editRow.children[2].innerText = order.exchange || '';
        editRow.children[3].innerText = order.strikePrice || '';
        editRow.children[4].innerText = order.expiry || '';

        // Entry
        const entryInput = document.createElement('input');
        entryInput.type = 'number'; entryInput.step = '0.01'; entryInput.value = order.entryPrice || '';
        entryInput.className = 'edit-input';
        editRow.children[5].appendChild(entryInput);

        // SL
        const slInput = document.createElement('input');
        slInput.type = 'number'; slInput.step = '0.01'; slInput.value = order.stopLoss || '';
        slInput.className = 'edit-input';
        editRow.children[6].appendChild(slInput);

        // Target1
        const t1Input = document.createElement('input');
        t1Input.type = 'number'; t1Input.step = '0.01'; t1Input.value = order.target1 || '';
        t1Input.className = 'edit-input';
        editRow.children[7].appendChild(t1Input);

        // Target2
        const t2Input = document.createElement('input');
        t2Input.type = 'number'; t2Input.step = '0.01'; t2Input.value = order.target2 || '';
        t2Input.className = 'edit-input';
        // small spacing
        const t2Label = document.createElement('div'); t2Label.style.display='inline-block'; t2Label.style.marginLeft='6px';
        t2Label.appendChild(t2Input);
        editRow.children[7].appendChild(t2Label);

        // Target3
        const t3Input = document.createElement('input');
        t3Input.type = 'number'; t3Input.step = '0.01'; t3Input.value = order.target3 || '';
        t3Input.className = 'edit-input';
        const t3Label = document.createElement('div'); t3Label.style.display='inline-block'; t3Label.style.marginLeft='6px';
        t3Label.appendChild(t3Input);
        editRow.children[7].appendChild(t3Label);

        // Qty
        const qtyInput = document.createElement('input');
        qtyInput.type = 'number'; qtyInput.step = '1'; qtyInput.value = order.quantity || '';
        qtyInput.className = 'edit-input';
        editRow.children[8].appendChild(qtyInput);

        // OptionType
         editRow.children[9].innerText = order.optionType || '';

        // Intraday checkbox
        const intradayBox = document.createElement('input');
        intradayBox.type = 'checkbox';
        intradayBox.checked = !!order.intraday;
        editRow.children[10].appendChild(intradayBox);

        // Status
        editRow.children[11].innerText = order.status || '';

        // Actions: Save/Cancel
        const saveBtn = document.createElement('button');
        saveBtn.className = 'small-btn';
        saveBtn.innerText = 'Save';
        saveBtn.onclick = function () {
            saveRequestEdit(id, {
                stopLoss: slInput.value,
                target1: t1Input.value,
                quantity: qtyInput.value,
                target2: t2Input.value,
                target3: t3Input.value,
                intraday: intradayBox.checked
            });
            return false;
        };

        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'small-btn';
        cancelBtn.innerText = 'Cancel';
        cancelBtn.onclick = function () { cancelEditRow(); return false; };

        editRow.children[12].appendChild(saveBtn);
        editRow.children[12].appendChild(cancelBtn);

        // LTP cell left blank (last cell)
        editRow.children[13].innerText = '--';

        // insert after the target row
        if (row) row.parentNode.insertBefore(editRow, row.nextSibling);
        else tbody.appendChild(editRow);
    }

    function saveRequestEdit(id, payload) {
        // build object with only non-empty values
        const body = {};
        if (payload.stopLoss !== null && payload.stopLoss !== '') body.stopLoss = parseFloat(payload.stopLoss);
        if (payload.target1 !== null && payload.target1 !== '') body.target1 = parseFloat(payload.target1);
        if (payload.target2 !== null && payload.target2 !== '') body.target2 = parseFloat(payload.target2);
        if (payload.target3 !== null && payload.target3 !== '') body.target3 = parseFloat(payload.target3);
        if (payload.quantity !== null && payload.quantity !== '' && !isNaN(payload.quantity)) body.quantity = parseInt(payload.quantity);
         if (typeof payload.intraday === 'boolean') body.intraday = payload.intraday;

         if (Object.keys(body).length === 0) { alert('No changes to save'); return; }

         fetch(`/api/trades/request/${id}`, {
             method: 'PUT',
             headers: {'Content-Type': 'application/json'},
             body: JSON.stringify(body)
         }).then(res => {
             if (!res.ok) throw new Error('Update failed');
             return res.json();
         }).then(updated => {
             alert('‚úÖ Updated request');
             cancelEditRow();
             loadRequestedOrders();
         }).catch(err => {
             console.error('Failed to update request', err);
             alert('‚ùå Failed to update request');
         });
     }

    function editExecution(id) {
         const setup = executionMap[id];
         if (!setup) {
            alert('Executed trade data not available locally. Refreshing executions.');
            loadTradeSetups();
            return;
        }
        // Do not allow editing rejected trades
        if (setup.status === 'REJECTED') {
            alert('Cannot edit a rejected execution');
            return;
        }
         cancelEditRow();

         const tbody = document.querySelector('#trades-executed-table tbody');
         // find row by data-id attribute (more robust than matching innerText)
         const row = tbody.querySelector(`tr[data-id="${id}"]`);
        const headerRow = document.querySelector('#trades-executed-table thead tr');
        const columnsCount = headerRow ? headerRow.children.length : 15; // fallback to 15 columns if header not found
        const editRow = createEditRow(columnsCount, 'exec_' + id);

        editRow.children[0].innerText = '';
        editRow.children[1].innerText = setup.symbol || '';
        editRow.children[2].innerText = setup.exchange || '';
        editRow.children[3].innerText = setup.strikePrice || '';
        editRow.children[4].innerText = setup.expiry || '';

        // Entry
        const entryInput = document.createElement('input');
        entryInput.type = 'number'; entryInput.step = '0.01'; entryInput.value = setup.entryPrice || '';
        entryInput.className = 'edit-input';
        editRow.children[5].appendChild(entryInput);

        // SL
        const slInput = document.createElement('input');
        slInput.type = 'number'; slInput.step = '0.01'; slInput.value = setup.stopLoss || '';
        slInput.className = 'edit-input';
        editRow.children[6].appendChild(slInput);

        // Target1
        const t1Input = document.createElement('input');
        t1Input.type = 'number'; t1Input.step = '0.01'; t1Input.value = setup.target1 || '';
        t1Input.className = 'edit-input';
        editRow.children[7].appendChild(t1Input);

        // Target2
        const t2Input = document.createElement('input');
        t2Input.type = 'number'; t2Input.step = '0.01'; t2Input.value = setup.target2 || '';
        t2Input.className = 'edit-input';
        const t2Label = document.createElement('div'); t2Label.style.display='inline-block'; t2Label.style.marginLeft='6px';
        t2Label.appendChild(t2Input);
        editRow.children[7].appendChild(t2Label);

        // Target3
        const t3Input = document.createElement('input');
        t3Input.type = 'number'; t3Input.step = '0.01'; t3Input.value = setup.target3 || '';
        t3Input.className = 'edit-input';
        const t3Label = document.createElement('div'); t3Label.style.display='inline-block'; t3Label.style.marginLeft='6px';
        t3Label.appendChild(t3Input);
        editRow.children[7].appendChild(t3Label);

        // Qty
        editRow.children[8].innerText = setup.quantity || '';

        // OptionType
        editRow.children[9].innerText = setup.optionType || '';

        // Intraday checkbox
        const intradayBox = document.createElement('input');
        intradayBox.type = 'checkbox';
        intradayBox.checked = !!setup.intraday;
        editRow.children[10].appendChild(intradayBox);

        // Status
        editRow.children[11].innerText = setup.status || '';

        // Actions: Save/Cancel
        const saveBtn = document.createElement('button');
        saveBtn.className = 'small-btn';
        saveBtn.innerText = 'Save';
        saveBtn.onclick = function () {
            saveExecutionEdit(id, {
                stopLoss: slInput.value,
                target1: t1Input.value,
                target2: t2Input.value,
                target3: t3Input.value,
                intraday: intradayBox.checked
            });
            return false;
        };

        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'small-btn';
        cancelBtn.innerText = 'Cancel';
        cancelBtn.onclick = function () { cancelEditRow(); return false; };

        editRow.children[12].appendChild(saveBtn);
        editRow.children[12].appendChild(cancelBtn);

        // LTP and PnL cells
        editRow.children[13].innerText = lastKnownLTP[setup.scripCode] ?? '-';
        editRow.children[14].innerText = lastKnownPNL[setup.scripCode] ?? '-';

        if (row) row.parentNode.insertBefore(editRow, row.nextSibling);
        else tbody.appendChild(editRow);
    }

    function saveExecutionEdit(id, payload) {
        const body = {};
        if (payload.stopLoss !== null && payload.stopLoss !== '') body.stopLoss = parseFloat(payload.stopLoss);
        if (payload.target1 !== null && payload.target1 !== '') body.target1 = parseFloat(payload.target1);
        if (payload.target2 !== null && payload.target2 !== '') body.target2 = parseFloat(payload.target2);
        if (payload.target3 !== null && payload.target3 !== '') body.target3 = parseFloat(payload.target3);
        if (typeof payload.intraday === 'boolean') body.intraday = payload.intraday;

        if (Object.keys(body).length === 0) { alert('No changes to save'); return; }

        fetch(`/api/trades/execution/${id}`, {
            method: 'PUT',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(body)
        }).then(res => {
            if (!res.ok) throw new Error('Update failed');
            return res.json();
        }).then(updated => {
            alert('‚úÖ Updated execution');
            cancelEditRow();
            loadTradeSetups();
        }).catch(err => {
            console.error('Failed to update execution', err);
            alert('‚ùå Failed to update execution');
        });
    }

    function cancelEditRow() {
        document.querySelectorAll('.edit-row').forEach(r => r.remove());
    }

    // Update loadRequestedOrders to add Edit button and data for editing
    function loadRequestedOrders() {
        // If user is editing a request inline, skip the automatic refresh to avoid wiping the editor
        if (document.querySelector('.edit-row[data-editing-for^="req_"]')) {
            console.debug('Skipping loadRequestedOrders() because a request is being edited');
            return;
        }
         fetch('/api/orders/requests')
             .then(res => res.json())
             .then(data => {
                 const tbody = document.querySelector("#trading-requests-table tbody");
                 tbody.innerHTML = "";
                 data.forEach(order => {
                     // store into requestMap for safe retrieval when Edit is clicked
                     requestMap[order.id] = order;
                     tbody.innerHTML += `
                     <tr data-id="${order.id}">
                         <td>${order.id}</td>
                         <td>${order.symbol}</td>
                         <td>${order.exchange}</td>
                         <td>${order.strikePrice}</td>
                         <td>${order.expiry}</td>
                         <td>${order.entryPrice}</td>
                         <td>${order.stopLoss}</td>
                         <td>${order.target1}</td>
                         <td>${order.quantity || ''}</td>
                         <td>${order.optionType || ''}</td>
                         <td>${order.intraday || ''}</td>
                         <td>${order.status || ''}</td>
                         <td>
                             <button onclick="cancelTradeRequest(${order.id})">Cancel</button>
                             <button onclick="editRequest(${order.id})">Edit</button>
                         </td>
                          <td data-scrip="${order.scripCode || ''}">--</td>
                     </tr>`;
                 });
             }).catch(err => console.error("Failed to load requested orders", err));
     }

     // Update loadTradeSetups to add Edit button for executed trades
     function loadTradeSetups() {
        // If user is editing an execution inline, skip the automatic refresh to avoid wiping the editor
        if (document.querySelector('.edit-row[data-editing-for^="exec_"]')) {
            console.debug('Skipping loadTradeSetups() because an execution is being edited');
            return;
        }
         fetch('/api/orders/executed')
             .then(res => res.json())
             .then(data => {
                 const tbody = document.querySelector("#trades-executed-table tbody");
                 tbody.innerHTML = "";
                 data.forEach(setup => {
                     executionMap[setup.id] = setup;
                     // If the execution is rejected, hide actions and don't show LTP / PnL
                     const isRejected = setup.status === 'REJECTED';
                     const actionCell = isRejected ? '<td></td>' : `
                         <td>
                             <button onclick="squareOffTrade(${setup.id})">Close</button>
                             <button onclick="moveSLtoCost(${setup.id})">MoveSLtoCost</button>
                             <button onclick="editExecution(${setup.id})">Edit</button>
                         </td>`;

                     const ltpCells = isRejected ?
                         `<td class="ltp">-</td><td class="pnl">-</td>` :
                         `<td class="ltp" data-scrip="${setup.scripCode}">${lastKnownLTP[setup.scripCode] ?? '-'}</td>
                          <td class="pnl" data-pnl="${setup.scripCode}">${lastKnownPNL[setup.scripCode] ?? '-'}</td>`;

                     tbody.innerHTML += `
             <tr data-id="${setup.id}" data-scrip="${setup.scripCode}" data-entry="${setup.entryPrice}" data-qty="${setup.quantity || 0}" data-rejected="${isRejected ? 'true' : 'false'}">
                 <td>${setup.id}</td>
                 <td>${setup.symbol}</td>
                 <td>${setup.exchange || ''}</td>
                 <td>${setup.strikePrice || ''}</td>
                 <td>${setup.expiry || ''}</td>
                 <td>${setup.entryPrice || ''}</td>
                 <td>${setup.stopLoss || ''}</td>
                 <td>${setup.target1 || ''}</td>
                 <td>${setup.quantity || ''}</td>
                 <td>${setup.optionType || ''}</td>
                 <td>${setup.intraday || ''}</td>
                 <td>${setup.status || ''}</td>
                 ${actionCell}
                 ${ltpCells}
             </tr>`;
                  });
             }).catch(err => console.error("Failed to load trade setups", err));
     }





    // Initialization: attach listeners and run initial loads when DOM is ready
    function initPlaceOrderPage() {
        // Attach event listeners that reference DOM elements (already done earlier in this script)
        // Run initial data fetches
        preloadInstruments();
        loadRequestedOrders();
        loadTradeSetups();

        // periodic refresh
        setInterval(() => {
            loadRequestedOrders(); // To reflect deletions if trade is executed
            loadTradeSetups();      // To reflect new setups
        }, 5000); // every 5 sec
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initPlaceOrderPage);
    } else {
        // DOM already available
        initPlaceOrderPage();
    }

    function fetchUnderlyingAndSelectNearestStrike(exchange, instrument, strikes) {
        // Map UI exchange to MStock underlying exchange codes
        const underlyingExchangeMap = { 'NF': 'NSE', 'BF': 'BSE' };
        const fnIndices = ['NIFTY', 'BANKNIFTY', 'FINNIFTY', 'MIDCPNIFTY'];
        const bfoIndices = ['SENSEX', 'BANKEX'];
        let qualified = '';

        const now = new Date();
        const yy = String(now.getFullYear()).slice(-2);
        const monthNames = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
        const mon = monthNames[now.getMonth()];

        if (fnIndices.includes(instrument)) {
            // NSE Index Futures: NFO:{symbol}{yy}{MON}FUT
            qualified = `NFO:${instrument}${yy}${mon}FUT`;
        } else if (bfoIndices.includes(instrument)) {
            // BSE Index Futures: BFO:{symbol}{yy}{MON}FUT
            qualified = `BFO:${instrument}${yy}${mon}FUT`;
        } else {
            // Regular NSE/BSE equity
            let mappedExchange = underlyingExchangeMap[exchange] || exchange;
            qualified = `${mappedExchange}:${instrument}`;
        }

        // build qualified key like 'NSE:ACC' or 'BSE:ACC'
        fetchMStockLtpForKey(qualified)
            .then(ltp => {
                if (ltp == null) return;

                // find nearest numeric strike from the provided strikes list
                const numericStrikes = strikes.map(s => Number(s)).filter(n => !isNaN(n));
                if (numericStrikes.length === 0) return;

                let nearest = numericStrikes[0];
                let bestDiff = Math.abs(nearest - ltp);
                numericStrikes.forEach(s => {
                    const diff = Math.abs(s - ltp);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        nearest = s;
                    }
                });
                const nearestStr = String(nearest);
                const strikeValue = nearestStr.includes('.') ? nearestStr : `${nearestStr}.0`;

                const strikeSelect = document.getElementById('strikePrice');
                strikeSelect.value = strikeValue;
                // trigger change so expiries are loaded and option LTP fetched
                strikeSelect.dispatchEvent(new Event('change'));
            })
            .catch(err => {
                console.warn('Could not fetch underlying LTP to choose nearest strike', err);
            });
    }

</script>

</body>
</html>
